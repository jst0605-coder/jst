<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>VR Therapeutic Golf World - Medical Assessment Platform</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
      body {
        margin: 0;
        font-family: 'Arial', sans-serif;
      }
      
      #game-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        color: white;
        text-align: center;
      }
      
      #game-overlay.hidden {
        display: none;
      }
      
      .overlay-content {
        background: rgba(255,255,255,0.1);
        padding: 40px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.2);
        max-width: 600px;
        width: 90%;
      }
      
      .esp-status {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 15px 20px;
        border-radius: 10px;
        z-index: 100;
        border: 2px solid #4CAF50;
      }
      
      .esp-status.disconnected {
        border-color: #F44336;
        color: #F44336;
      }
      
      .gaze-cursor {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 4px;
        background: #FFD700;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 50;
        pointer-events: none;
        box-shadow: 0 0 10px #FFD700;
      }
      
      .session-timer {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0,0,0,0.8);
        color: #FFD700;
        padding: 15px 25px;
        border-radius: 15px;
        font-size: 24px;
        font-weight: bold;
        z-index: 100;
        border: 2px solid #FFD700;
      }
      
      /* VR-FRIENDLY HUD */
      body:not(.vr-mode) .performance-hud {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 15px;
        border-radius: 10px;
        font-size: 14px;
        z-index: 100;
        min-width: 200px;
        max-width: 220px;
      }
      
      /* Enhanced Mode Indicator */
      body:not(.vr-mode) .mode-indicator {
        position: fixed;
        top: 200px;
        left: 20px;
        background: rgba(0,0,0,0.9);
        color: white;
        padding: 15px;
        border-radius: 10px;
        font-size: 14px;
        z-index: 100;
        min-width: 250px;
        border: 2px solid #FF9800;
        text-align: center;
      }
      
      .mode-indicator.golf-mode {
        border-color: #4CAF50;
        background: rgba(76, 175, 80, 0.2);
      }
      
      .mode-indicator.walk-mode {
        border-color: #2196F3;
        background: rgba(33, 150, 243, 0.2);
      }
      
      .mode-indicator.golf-ready {
        border-color: #FFD700;
        background: rgba(255, 215, 0, 0.2);
        animation: golfPulse 2s infinite;
      }
      
      @keyframes golfPulse {
        0% { box-shadow: 0 0 5px #FFD700; }
        50% { box-shadow: 0 0 20px #FFD700; }
        100% { box-shadow: 0 0 5px #FFD700; }
      }
      
      /* Hide HUD elements in VR mode */
      body.vr-mode .performance-hud,
      body.vr-mode .mode-indicator {
        display: none !important;
      }
      
      .btn {
        padding: 15px 30px;
        font-size: 18px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        margin: 10px;
        background: linear-gradient(45deg, #4CAF50, #45a049);
        color: white;
        transition: all 0.3s;
      }
      
      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      }
      
      .btn-secondary {
        background: linear-gradient(45deg, #2196F3, #1976D2);
      }
      
      #esp-settings {
        margin: 20px 0;
        background: rgba(255,255,255,0.1);
        padding: 20px;
        border-radius: 10px;
      }
      
      #esp-settings input {
        padding: 10px;
        margin: 5px;
        border-radius: 5px;
        border: none;
        width: 200px;
      }
      
      #results-dashboard {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(135deg, #2C3E50, #34495E);
        z-index: 2000;
        overflow-y: auto;
        padding: 20px;
        display: none;
        color: white;
      }
      
      .dashboard-header {
        text-align: center;
        margin-bottom: 30px;
      }
      
      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }
      
      .metric-card {
        background: rgba(255,255,255,0.1);
        padding: 20px;
        border-radius: 15px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.2);
      }
      
      .chart-container {
        background: rgba(255,255,255,0.95);
        padding: 20px;
        border-radius: 15px;
        margin: 20px 0;
        color: #333;
      }
      
      .charts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }
      
      .report-actions {
        text-align: center;
        margin: 30px 0;
      }
      
      #physician-notes {
        width: 100%;
        min-height: 120px;
        padding: 15px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.3);
        background: rgba(255,255,255,0.1);
        color: white;
        font-family: inherit;
        resize: vertical;
      }
      
      #physician-notes::placeholder {
        color: rgba(255,255,255,0.7);
      }
      
      .assessment-score {
        font-size: 48px;
        font-weight: bold;
        color: #4CAF50;
        text-align: center;
        margin: 20px 0;
      }
      
      .progress-bar {
        width: 100%;
        height: 6px;
        background: rgba(255,255,255,0.2);
        border-radius: 3px;
        overflow: hidden;
        margin: 8px 0;
      }
      
      .progress-fill {
        height: 100%;
        background: linear-gradient(45deg, #4CAF50, #45a049);
        transition: width 0.3s ease;
      }

      .data-table {
        width: 100%;
        border-collapse: collapse;
        margin: 10px 0;
      }

      .data-table th,
      .data-table td {
        padding: 8px 12px;
        text-align: left;
        border-bottom: 1px solid rgba(255,255,255,0.2);
      }

      .data-table th {
        background: rgba(255,255,255,0.1);
        font-weight: bold;
      }

      .metric-value {
        font-size: 24px;
        font-weight: bold;
        color: #4CAF50;
      }

      .metric-label {
        font-size: 14px;
        color: rgba(255,255,255,0.8);
        margin-bottom: 5px;
      }

      /* Golf Power Meter */
      .golf-power-meter {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        width: 300px;
        height: 60px;
        background: rgba(0,0,0,0.8);
        border-radius: 10px;
        padding: 10px;
        display: none;
        z-index: 200;
      }

      .power-meter-fill {
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #4CAF50, #FFD700, #F44336);
        border-radius: 5px;
        transition: width 0.1s;
      }
    </style>
  </head>
  <body>
    <!-- Gaze Cursor -->
    <div class="gaze-cursor" id="gaze-cursor"></div>
    
    <!-- ESP32 Status -->
    <div class="esp-status disconnected" id="esp-status">
      üì° ESP32: Disconnected
    </div>
    
    <!-- Performance HUD -->
    <div class="performance-hud" id="performance-hud" style="display: none;">
      <div><strong>üéØ Session Progress</strong></div>
      <div class="progress-bar">
        <div class="progress-fill" id="session-progress" style="width: 0%;"></div>
      </div>
      <div>‚õ≥ Shots: <span id="shot-count">0</span></div>
      <div>üéØ Accuracy: <span id="accuracy">0%</span></div>
      <div>üèÜ Score: <span id="current-score">0</span></div>
      <div>üå∏ Explored: <span id="exploration-distance">0m</span></div>
    </div>

    <!-- Enhanced Mode Indicator -->
    <div class="mode-indicator walk-mode" id="mode-indicator" style="display: none;">
      <div><strong>üö∂ WALK MODE</strong></div>
      <div style="font-size: 12px; margin-top: 5px;">Elbow bend = move, Finger flex = collect</div>
    </div>

    <!-- Golf Power Meter -->
    <div class="golf-power-meter" id="golf-power-meter">
      <div style="color: white; font-size: 12px; margin-bottom: 5px;">Golf Power</div>
      <div class="power-meter-fill" id="power-meter-fill"></div>
    </div>

    <!-- Game Start/End Overlay -->
    <div id="game-overlay">
      <div class="overlay-content">
        <h1 id="overlay-title">üèåÔ∏è VR Therapeutic Golf World Assessment</h1>
        <p id="overlay-description">
          A 10-minute therapeutic VR experience with ESP32 sensor control and gaze interaction.
          FINAL FIX: Auto-collection eliminated, golf properly exits, ball always returns!
        </p>
        
        <div id="esp-settings">
          <h3>ESP32 Connection</h3>
          <input type="text" id="esp-ip" placeholder="ESP32 IP Address (e.g., 192.168.0.129)" value="192.168.0.129">
          <br>
          <button id="connect-esp" class="btn btn-secondary" onclick="connectESP32()">üì° Connect to ESP32</button>
          <div id="connection-status" style="margin-top: 10px; color: #FFD700;"></div>
        </div>
        
        <div id="patient-info" style="margin: 20px 0;">
          <input type="text" id="patient-name" placeholder="Patient Name" 
                 style="padding: 10px; margin: 5px; border-radius: 5px; border: none; width: 200px;">
          <input type="text" id="patient-id" placeholder="Patient ID" 
                 style="padding: 10px; margin: 5px; border-radius: 5px; border: none; width: 200px;">
        </div>
        <button id="start-session" class="btn" onclick="startSession()">üéØ Start 10-Minute Assessment</button>
        <button id="view-demo" class="btn btn-secondary" onclick="startDemo()">üëÅÔ∏è View Demo Mode</button>
      </div>
    </div>

    <!-- Session Timer -->
    <div class="session-timer" id="session-timer" style="display: none;">
      ‚è±Ô∏è <span id="time-remaining">10:00</span>
    </div>

    <!-- Results Dashboard -->
    <div id="results-dashboard">
      <div class="dashboard-header">
        <h1>üìä Therapeutic Assessment Results</h1>
        <div id="patient-summary"></div>
      </div>
      
      <!-- Session Metadata -->
      <div class="metric-card">
        <h3>üìã Session Metadata</h3>
        <table class="data-table">
          <tr>
            <td><strong>Patient Name:</strong></td>
            <td id="meta-patient-name">-</td>
          </tr>
          <tr>
            <td><strong>Patient ID:</strong></td>
            <td id="meta-patient-id">-</td>
          </tr>
          <tr>
            <td><strong>Assessment Date:</strong></td>
            <td id="meta-date">-</td>
          </tr>
          <tr>
            <td><strong>Session Duration:</strong></td>
            <td id="meta-duration">-</td>
          </tr>
          <tr>
            <td><strong>Task/Game:</strong></td>
            <td>VR Therapeutic Golf Assessment</td>
          </tr>
          <tr>
            <td><strong>ESP32 Status:</strong></td>
            <td id="meta-esp32-status">-</td>
          </tr>
        </table>
      </div>

      <div class="metrics-grid">
        <!-- Flex Sensor Results -->
        <div class="metric-card">
          <h3>üìê Flex Sensor Results</h3>
          <table class="data-table">
            <thead>
              <tr>
                <th>Metric</th>
                <th>Flex 1</th>
                <th>Flex 2</th>
                <th>Flex 3</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Baseline Value</td>
                <td id="flex1-baseline">0</td>
                <td id="flex2-baseline">0</td>
                <td id="flex3-baseline">0</td>
              </tr>
              <tr>
                <td>Average During Game</td>
                <td id="flex1-avg">0</td>
                <td id="flex2-avg">0</td>
                <td id="flex3-avg">0</td>
              </tr>
              <tr>
                <td>Peak Value (Max)</td>
                <td id="flex1-peak">0</td>
                <td id="flex2-peak">0</td>
                <td id="flex3-peak">0</td>
              </tr>
              <tr>
                <td>Reps Above Threshold</td>
                <td id="flex1-reps">0</td>
                <td id="flex2-reps">0</td>
                <td id="flex3-reps">0</td>
              </tr>
            </tbody>
          </table>
        </div>
        
        <!-- IMU Results -->
        <div class="metric-card">
          <h3>üîÑ IMU Results</h3>
          <div class="metric-label">Baseline Tilt</div>
          <div class="metric-value" id="imu-baseline">0¬∞</div>
          <div class="metric-label">Max Tilt ROM</div>
          <div class="metric-value" id="imu-max-rom">0¬∞</div>
          <div class="metric-label">Average Tilt During Game</div>
          <div class="metric-value" id="imu-avg">0¬∞</div>
          <div class="metric-label">Stability Index</div>
          <div class="metric-value" id="imu-stability">0%</div>
          <div class="metric-label">Repetitions</div>
          <div class="metric-value" id="imu-repetitions">0</div>
        </div>
        
        <!-- Performance & Engagement -->
        <div class="metric-card">
          <h3>üéØ Performance & Engagement</h3>
          <div class="metric-label">Task Success Rate</div>
          <div class="metric-value" id="task-success-rate">0%</div>
          <div class="metric-label">Errors (Missed Cues)</div>
          <div class="metric-value" id="missed-cues">0</div>
          <div class="metric-label">Average Reaction Time</div>
          <div class="metric-value" id="avg-reaction-time">0ms</div>
          <div class="metric-label">Active Time</div>
          <div class="metric-value" id="active-time">0min</div>
          <div class="metric-label">Idle Time</div>
          <div class="metric-value" id="idle-time">0min</div>
          <div class="metric-label">Engagement Ratio</div>
          <div class="metric-value" id="engagement-ratio">0%</div>
        </div>
      </div>
      
      <!-- Charts Section -->
      <div class="charts-grid">
        <div class="chart-container">
          <h3>üìä Flex Sensor Waveforms (Bending Cycles)</h3>
          <canvas id="flex-waveform-chart" width="400" height="300"></canvas>
        </div>
        
        <div class="chart-container">
          <h3>üîÑ IMU Tilt Over Time (ROM & Stability)</h3>
          <canvas id="imu-tilt-chart" width="400" height="300"></canvas>
        </div>
        
        <div class="chart-container">
          <h3>‚è±Ô∏è Engagement: Active vs Idle Time</h3>
          <canvas id="engagement-pie-chart" width="400" height="300"></canvas>
        </div>
        
        <div class="chart-container">
          <h3>‚úÖ Success vs Failure Analysis</h3>
          <canvas id="success-failure-chart" width="400" height="300"></canvas>
        </div>
      </div>
      
      <div class="metric-card">
        <h3>üìã Clinical Notes</h3>
        <textarea id="physician-notes" placeholder="Enter clinical observations, recommendations, or treatment notes..."></textarea>
      </div>
      
      <div class="report-actions">
        <button onclick="exportPDF()" class="btn">üìÑ Export PDF Report</button>
        <button onclick="exportCSV()" class="btn btn-secondary">üìä Export Data CSV</button>
        <button onclick="newSession()" class="btn" style="background: linear-gradient(45deg, #FF9800, #F57C00);">
          üîÑ New Session
        </button>
      </div>
    </div>

    <!-- VR Scene -->
    <a-scene vr-mode-ui="enabled: true" 
             background="color: #87CEEB" 
             fog="type: exponential; density: 0.0008; color: #87CEEB"
             renderer="antialias: true; highRefreshRate: true"
             shadow="type: basic"
             id="vr-scene"
             embedded
             style="height: 100vh; width: 100vw;">
      
      <!-- Sky -->
      <a-sky color="#87CEEB"></a-sky>
      
      <!-- Large Ground Circle -->
      <a-cylinder position="0 -0.1 0" radius="70" height="0.2" 
                  color="#2E7D32" 
                  material="roughness: 0.8; metalness: 0.1"
                  shadow="receive: true"></a-cylinder>
      
      <!-- Apartment Building -->
      <a-entity gltf-model="https://jst0605-coder.github.io/jst/Apartment%202.glb"
                scale="20 20 20"
                position="0 3 -55"
                shadow="cast: true; receive: true"></a-entity>
      
      <!-- Cloud -->
      <a-entity gltf-model="https://jst0605-coder.github.io/jst/cloud.glb"
                scale="8 8 8"
                position="0 25 -60"
                animation="property: position; to: 40 25 -60; dur: 40000; loop: true; dir: alternate">
      </a-entity>
      
      <!-- Birds -->
      <a-entity gltf-model="https://jst0605-coder.github.io/jst/birds.glb"
                scale="4 4 4"
                rotation="0 90 0"
                position="-40 18 -40"
                animation="property: position; to: 40 20 -40; dur: 25000; loop: true; dir: alternate">
      </a-entity>
      
      <!-- VR CONTROL GUIDE -->
      <a-entity id="vr-control-guide" position="0 3 12" rotation="0 0 0">
        <a-plane position="0 0 0" width="6" height="4" 
                 color="#000000" 
                 material="opacity: 0.8; transparent: true"
                 geometry="primitive: plane"></a-plane>
        
        <a-text position="0 1.5 0.01" 
                value="üéÆ FINAL FIXED CONTROLS" 
                color="#FFD700" 
                scale="0.8 0.8 0.8" 
                align="center"
                font="kelsonsans"></a-text>
        
        <a-text position="0 1 0.01" 
                value="üö∂ WALK: Elbow bend = smooth movement" 
                color="#2196F3" 
                scale="0.5 0.5 0.5" 
                align="center"
                font="kelsonsans"></a-text>
        
        <a-text position="0 0.5 0.01" 
                value="üí∞ COLLECT: MUST flex finger (no auto)" 
                color="#FFD700" 
                scale="0.5 0.5 0.5" 
                align="center"
                font="kelsonsans"></a-text>
        
        <a-text position="0 0 0.01" 
                value="üèåÔ∏è GOLF: Look at ball + hold finger flex" 
                color="#4CAF50" 
                scale="0.5 0.5 0.5" 
                align="center"
                font="kelsonsans"></a-text>
        
        <a-text position="0 -0.5 0.01" 
                value="‚ö° POWER: Add elbow while holding flex" 
                color="#E91E63" 
                scale="0.5 0.5 0.5" 
                align="center"
                font="kelsonsans"></a-text>
        
        <a-text position="0 -1 0.01" 
                value="üîÑ Ball ALWAYS returns to tee!" 
                color="#FFFFFF" 
                scale="0.4 0.4 0.4" 
                align="center"
                font="kelsonsans"></a-text>
      </a-entity>
      
      <!-- Environment Trees -->
      <a-entity id="environment-decorations">
        <!-- Far North Ring - Elevated -->
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="0 12 45" scale="6.0 10.0 6.0" shadow="cast: true"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="25 12 42" scale="5.5 9.5 5.5" shadow="cast: true"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="-25 12 42" scale="5.5 9.5 5.5" shadow="cast: true"></a-entity>
        
        <!-- East Ring - Elevated -->
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="50 13 0" scale="6.5 11.0 6.5" shadow="cast: true"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="45 12 20" scale="5.8 9.8 5.8" shadow="cast: true"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="48 12 -15" scale="6.0 10.0 6.0" shadow="cast: true"></a-entity>
        
        <!-- West Ring - Elevated -->
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="-50 13 0" scale="6.5 11.0 6.5" shadow="cast: true"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="-45 12 20" scale="5.8 9.8 5.8" shadow="cast: true"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="-48 12 -15" scale="6.0 10.0 6.0" shadow="cast: true"></a-entity>
        
        <!-- South Ring - Elevated -->
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="20 11 -65" scale="5.5 9.0 5.5" shadow="cast: true"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="-20 11 -65" scale="5.5 9.0 5.5" shadow="cast: true"></a-entity>
        
        <!-- Medium Trees - Elevated -->
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="12 10 25" scale="4.5 7.5 4.5" shadow="cast: true"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="-12 10 25" scale="4.5 7.5 4.5" shadow="cast: true"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="35 10 15" scale="4.8 8.0 4.8" shadow="cast: true"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Big%20Tree.glb" position="-35 10 15" scale="4.8 8.0 4.8" shadow="cast: true"></a-entity>
        
        <!-- Grass patches -->
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Grass%20Patch.glb" position="8 0 30" scale="1.2 1.2 1.2"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Grass%20Patch.glb" position="-10 0 28" scale="1.0 1.0 1.0"></a-entity>
        <a-entity gltf-model="https://jst0605-coder.github.io/jst/Grass%20Patch.glb" position="18 0 18" scale="1.1 1.1 1.1"></a-entity>
      </a-entity>
      
      <!-- Scattered Flowers -->
      <a-entity id="scattered-flowers"></a-entity>
      
      <!-- Assessment Animals with AI -->
      <a-entity id="roaming-animals">
        <a-entity class="assessment-animal roaming-animal touchable" 
                  gltf-model="https://jst0605-coder.github.io/jst/Animated%20Animal%20Pack-glb/Fox.glb" 
                  animation-mixer
                  position="-20 0 15"
                  scale="0.8 0.8 0.8" 
                  shadow="cast: true"
                  animal-ai="speed: 1.0; wanderRadius: 15; homePosition: -20 0 15">
        </a-entity>
        
        <a-entity class="assessment-animal roaming-animal touchable" 
                  gltf-model="https://jst0605-coder.github.io/jst/Animated%20Animal%20Pack-glb/Husky.glb" 
                  animation-mixer
                  position="22 0 12"
                  scale="0.9 0.9 0.9" 
                  shadow="cast: true"
                  animal-ai="speed: 1.2; wanderRadius: 12; homePosition: 22 0 12">
        </a-entity>
        
        <a-entity class="assessment-animal roaming-animal touchable" 
                  gltf-model="https://jst0605-coder.github.io/jst/Animated%20Animal%20Pack-glb/Shiba%20Inu.glb" 
                  animation-mixer
                  position="25 0 -8"
                  scale="0.7 0.7 0.7" 
                  shadow="cast: true"
                  animal-ai="speed: 1.5; wanderRadius: 10; homePosition: 25 0 -8">
        </a-entity>
        
        <a-entity class="assessment-animal roaming-animal touchable" 
                  gltf-model="https://jst0605-coder.github.io/jst/Animated%20Animal%20Pack-glb/Horse.glb" 
                  animation-mixer
                  position="-25 0 -8"
                  scale="1.6 1.6 1.6" 
                  shadow="cast: true"
                  animal-ai="speed: 1.8; wanderRadius: 15; homePosition: -25 0 -8">
        </a-entity>
      </a-entity>
      
      <!-- Assessment Coins -->
      <a-entity id="assessment-coins">
        <a-entity class="assessment-coin gazeable" position="5 0.1 18">
          <a-entity gltf-model="https://jst0605-coder.github.io/jst/Coin.glb" 
                    scale="0.5 0.5 0.5"
                    animation="property: rotation; to: 0 360 0; dur: 2000; loop: true"
                    shadow="cast: true"></a-entity>
        </a-entity>
        
        <a-entity class="assessment-coin gazeable" position="-8 0.1 25">
          <a-entity gltf-model="https://jst0605-coder.github.io/jst/Coin.glb" 
                    scale="0.5 0.5 0.5"
                    animation="property: rotation; to: 0 360 0; dur: 1800; loop: true"
                    shadow="cast: true"></a-entity>
        </a-entity>
        
        <a-entity class="assessment-coin gazeable" position="18 0.1 -5">
          <a-entity gltf-model="https://jst0605-coder.github.io/jst/Coin.glb" 
                    scale="0.5 0.5 0.5"
                    animation="property: rotation; to: 0 360 0; dur: 2200; loop: true"
                    shadow="cast: true"></a-entity>
        </a-entity>
        
        <a-entity class="assessment-coin gazeable" position="-22 0.1 8">
          <a-entity gltf-model="https://jst0605-coder.github.io/jst/Coin.glb" 
                    scale="0.5 0.5 0.5"
                    animation="property: rotation; to: 0 360 0; dur: 1900; loop: true"
                    shadow="cast: true"></a-entity>
        </a-entity>
        
        <a-entity class="assessment-coin gazeable" position="30 0.1 25">
          <a-entity gltf-model="https://jst0605-coder.github.io/jst/Coin.glb" 
                    scale="0.5 0.5 0.5"
                    animation="property: rotation; to: 0 360 0; dur: 2100; loop: true"
                    shadow="cast: true"></a-entity>
        </a-entity>
        
        <a-entity class="assessment-coin gazeable" position="-28 0.1 -12">
          <a-entity gltf-model="https://jst0605-coder.github.io/jst/Coin.glb" 
                    scale="0.5 0.5 0.5"
                    animation="property: rotation; to: 0 360 0; dur: 1700; loop: true"
                    shadow="cast: true"></a-entity>
        </a-entity>
      </a-entity>
      
      <!-- EASY GOLF COURSE - Left side -->
      <a-entity id="easy-golf-course" position="-20 0 -25">
        <!-- Course borders -->
        <a-box position="0 0.4 15" depth="2" height="0.8" width="25" 
               color="#8D6E63" shadow="cast: true; receive: true"></a-box>
        <a-box position="-12 0.4 7.5" depth="15" height="0.8" width="2" 
               color="#8D6E63" shadow="cast: true; receive: true"></a-box>
        <a-box position="12 0.4 7.5" depth="15" height="0.8" width="2" 
               color="#8D6E63" shadow="cast: true; receive: true"></a-box>
        <a-box position="0 0.4 0" depth="2" height="0.8" width="25" 
               color="#8D6E63" shadow="cast: true; receive: true"></a-box>
        
        <!-- Tee area -->
        <a-cylinder position="0 0.08 12" radius="2.5" height="0.15" 
                    color="#8BC34A" shadow="cast: true; receive: true"></a-cylinder>
        
        <!-- Easy ball with enhanced visibility -->
        <a-sphere id="easy-ball" class="gazeable golf-ball" position="0 0.2 12" radius="0.2" 
                  color="#FFFFFF" shadow="cast: true"
                  material="emissive: #FFFFFF; emissiveIntensity: 0.3">
          <a-ring position="0 0.1 0" radius-inner="0.3" radius-outer="0.5" 
                  color="#FFD700" rotation="-90 0 0" 
                  material="opacity: 0.7; transparent: true"
                  animation="property: rotation; to: -90 360 0; dur: 3000; loop: true"></a-ring>
        </a-sphere>
        
        <!-- Course fairway -->
        <a-box position="0 0.05 7.5" width="20" height="0.1" depth="15" 
               color="#4CAF50" shadow="receive: true"></a-box>
        
        <!-- Green area -->
        <a-cylinder position="0 0.1 3" radius="2.5" height="0.2" 
                    color="#2E7D32" shadow="cast: true; receive: true"></a-cylinder>
        
        <!-- Easy hole with flag detection zone -->
        <a-cylinder id="easy-hole" position="0 0.05 3" radius="0.4" height="0.4" 
                    color="#000000" shadow="receive: true"></a-cylinder>
        <a-cylinder id="easy-flag-zone" position="0 0.1 3" radius="2" height="0.1" 
                    color="#FFD700" material="opacity: 0.2; transparent: true"
                    visible="false"></a-cylinder>
        
        <!-- Flag -->
        <a-cylinder position="0 2.5 3" radius="0.05" height="5" color="#4CAF50" shadow="cast: true"></a-cylinder>
        <a-plane position="0.8 4 3" width="1.6" height="1.2" color="#4CAF50" 
                 animation="property: rotation; to: 0 15 0; dur: 3000; loop: true; dir: alternate"></a-plane>
      </a-entity>
      
      <!-- ENHANCED CHALLENGING GOLF COURSE -->
      <a-entity id="challenging-golf-course" position="20 0 -25">
        <!-- Course borders - Higher and more imposing -->
        <a-box position="0 0.8 18" depth="2" height="1.6" width="32" 
               color="#5D4037" shadow="cast: true; receive: true"></a-box>
        <a-box position="-16 0.8 9" depth="20" height="1.6" width="2" 
               color="#5D4037" shadow="cast: true; receive: true"></a-box>
        <a-box position="16 0.8 9" depth="20" height="1.6" width="2" 
               color="#5D4037" shadow="cast: true; receive: true"></a-box>
        <a-box position="0 0.8 0" depth="2" height="1.6" width="32" 
               color="#5D4037" shadow="cast: true; receive: true"></a-box>
        
        <!-- Enhanced Tee area with platform -->
        <a-cylinder position="0 0.15 15" radius="3.5" height="0.3" 
                    color="#8BC34A" shadow="cast: true; receive: true"></a-cylinder>
        <a-text position="0 0.5 13" value="CHALLENGING TEE" color="#FFFFFF" scale="0.8 0.8 0.8" align="center"></a-text>
        
        <!-- Challenging ball with enhanced effects -->
        <a-sphere id="challenging-ball" class="gazeable golf-ball" position="0 0.35 15" radius="0.2" 
                  color="#FFFFFF" shadow="cast: true"
                  material="emissive: #FFFFFF; emissiveIntensity: 0.3">
          <a-ring position="0 0.1 0" radius-inner="0.3" radius-outer="0.5" 
                  color="#E53935" rotation="-90 0 0" 
                  material="opacity: 0.7; transparent: true"
                  animation="property: rotation; to: -90 360 0; dur: 2000; loop: true"></a-ring>
        </a-sphere>
        
        <!-- Multi-level fairway with elevation changes -->
        <a-box position="0 0.05 12" width="26" height="0.1" depth="6" 
               color="#4CAF50" shadow="receive: true"></a-box>
        <!-- Elevated narrow bridge section -->
        <a-box position="0 0.2 7" width="6" height="0.2" depth="4" 
               color="#66BB6A" shadow="receive: true"></a-box>
        <!-- Final approach with slope -->
        <a-box position="0 0.1 3" width="10" height="0.15" depth="4" 
               color="#4CAF50" shadow="receive: true"
               rotation="0 0 2"></a-box>
        
        <!-- Enhanced water hazards with animation -->
        <a-circle position="-6 0.05 9" radius="4" rotation="-90 0 0" 
                  color="#1976D2" 
                  material="roughness: 0.1; metalness: 0.3; opacity: 0.9; transparent: true"
                  animation="property: material.opacity; to: 0.6; dur: 2000; loop: true; dir: alternate"></a-circle>
        <a-circle position="6 0.05 9" radius="4" rotation="-90 0 0" 
                  color="#1976D2" 
                  material="roughness: 0.1; metalness: 0.3; opacity: 0.9; transparent: true"
                  animation="property: material.opacity; to: 0.6; dur: 2000; loop: true; dir: alternate"></a-circle>
        
        <!-- Moving island stepping stones -->
        <a-cylinder position="-3 0.1 8" radius="0.8" height="0.2" 
                    color="#8BC34A" shadow="cast: true; receive: true"
                    animation="property: position; to: -1 0.1 8; dur: 4000; loop: true; dir: alternate"></a-cylinder>
        <a-cylinder position="0 0.1 9" radius="0.8" height="0.2" 
                    color="#8BC34A" shadow="cast: true; receive: true"
                    animation="property: position; to: 2 0.1 9; dur: 5000; loop: true; dir: alternate"></a-cylinder>
        <a-cylinder position="3 0.1 10" radius="0.8" height="0.2" 
                    color="#8BC34A" shadow="cast: true; receive: true"
                    animation="property: position; to: 1 0.1 10; dur: 3500; loop: true; dir: alternate"></a-cylinder>
        
        <!-- Enhanced windmill obstacles with varying speeds -->
        <a-entity position="-10 0 12">
          <a-cylinder radius="0.4" height="6" color="#8D6E63" position="0 3 0" shadow="cast: true"></a-cylinder>
          <a-entity animation="property: rotation; to: 0 360 0; dur: 1200; loop: true">
            <a-box width="6" height="0.4" depth="0.4" color="#E53935" position="0 6 0" shadow="cast: true"></a-box>
            <a-box width="0.4" height="6" depth="0.4" color="#E53935" position="0 6 0" shadow="cast: true"></a-box>
          </a-entity>
        </a-entity>
        
        <a-entity position="10 0 12">
          <a-cylinder radius="0.4" height="6" color="#8D6E63" position="0 3 0" shadow="cast: true"></a-cylinder>
          <a-entity animation="property: rotation; to: 0 -360 0; dur: 1800; loop: true">
            <a-box width="6" height="0.4" depth="0.4" color="#FF5722" position="0 6 0" shadow="cast: true"></a-box>
            <a-box width="0.4" height="6" depth="0.4" color="#FF5722" position="0 6 0" shadow="cast: true"></a-box>
          </a-entity>
        </a-entity>
        
        <!-- Moving barriers -->
        <a-box position="-8 1 6" width="1" height="2" depth="4" color="#795548" 
               shadow="cast: true"
               animation="property: position; to: 8 1 6; dur: 8000; loop: true; dir: alternate"></a-box>
        <a-box position="8 1 14" width="1" height="2" depth="4" color="#795548" 
               shadow="cast: true"
               animation="property: position; to: -8 1 14; dur: 6000; loop: true; dir: alternate"></a-box>
        
        <!-- Enhanced green with undulation -->
        <a-cylinder position="0 0.15 3" radius="3.5" height="0.3" 
                    color="#2E7D32" shadow="cast: true; receive: true"></a-cylinder>
        <!-- Undulating sections of green -->
        <a-cylinder position="-1.5 0.2 2" radius="1" height="0.1" 
                    color="#1B5E20" shadow="cast: true; receive: true"></a-cylinder>
        <a-cylinder position="1.5 0.1 4" radius="1" height="0.1" 
                    color="#1B5E20" shadow="cast: true; receive: true"></a-cylinder>
        
        <!-- Enhanced hole with flag detection zone -->
        <a-cylinder id="challenging-hole" position="0 0.2 3" radius="0.35" height="0.4" 
                    color="#000000" shadow="receive: true"></a-cylinder>
        <a-cylinder id="challenging-flag-zone" position="0 0.15 3" radius="2.5" height="0.1" 
                    color="#E53935" material="opacity: 0.2; transparent: true"
                    visible="false"></a-cylinder>
        
        <!-- Animated hole indicator -->
        <a-ring position="0 0.21 3" radius-inner="0.35" radius-outer="0.6" 
                color="#FFD700" rotation="-90 0 0"
                animation="property: material.opacity; to: 0.3; dur: 1000; loop: true; dir: alternate"></a-ring>
        
        <!-- Enhanced flag with wind effect -->
        <a-cylinder position="0 2.5 3" radius="0.08" height="5" color="#E53935" shadow="cast: true"></a-cylinder>
        <a-plane position="1.5 4 3" width="3" height="2" color="#FF5722" 
                 animation="property: rotation; to: 0 35 5; dur: 1200; loop: true; dir: alternate"
                 animation__wave="property: scale; to: 1.1 0.9 1; dur: 800; loop: true; dir: alternate"></a-plane>
        
        <!-- Enhanced sand traps with depth -->
        <a-circle position="-12 0.01 6" radius="3" rotation="-90 0 0" color="#F4A460" material="roughness: 0.9"></a-circle>
        <a-circle position="-12 -0.1 6" radius="2.5" rotation="-90 0 0" color="#DEB887" material="roughness: 0.9"></a-circle>
        <a-circle position="12 0.01 6" radius="3" rotation="-90 0 0" color="#F4A460" material="roughness: 0.9"></a-circle>
        <a-circle position="12 -0.1 6" radius="2.5" rotation="-90 0 0" color="#DEB887" material="roughness: 0.9"></a-circle>
        
        <!-- Additional strategic hazards -->
        <a-circle position="-6 0.01 16" radius="2.5" rotation="-90 0 0" color="#F4A460" material="roughness: 0.9"></a-circle>
        <a-circle position="6 0.01 16" radius="2.5" rotation="-90 0 0" color="#F4A460" material="roughness: 0.9"></a-circle>
        
        <!-- Rough areas with texture -->
        <a-circle position="-14 0.01 9" radius="3.5" rotation="-90 0 0" color="#795548" material="roughness: 1.0"></a-circle>
        <a-circle position="14 0.01 9" radius="3.5" rotation="-90 0 0" color="#795548" material="roughness: 1.0"></a-circle>
        
        <!-- Enhanced course markers with information -->
        <a-cylinder position="-16 1 9" radius="0.15" height="2.5" color="#FFD700" shadow="cast: true"></a-cylinder>
        <a-text position="-16 3 9" value="200m" color="#FFD700" scale="1 1 1" align="center"></a-text>
        <a-text position="-16 2.5 9" value="ROUGH" color="#FF5722" scale="0.6 0.6 0.6" align="center"></a-text>
        
        <a-cylinder position="0 1 9" radius="0.15" height="2.5" color="#FFD700" shadow="cast: true"></a-cylinder>
        <a-text position="0 3 9" value="150m" color="#FFD700" scale="1 1 1" align="center"></a-text>
        <a-text position="0 2.5 9" value="WATER" color="#2196F3" scale="0.6 0.6 0.6" align="center"></a-text>
        
        <a-cylinder position="0 1 6" radius="0.15" height="2.5" color="#FFD700" shadow="cast: true"></a-cylinder>
        <a-text position="0 3 6" value="100m" color="#FFD700" scale="1 1 1" align="center"></a-text>
        <a-text position="0 2.5 6" value="DANGER" color="#E53935" scale="0.6 0.6 0.6" align="center"></a-text>
      </a-entity>
      
      <!-- Course Labels -->
      <a-text position="-20 3 -10" 
              value="üèåÔ∏è EASY GOLF COURSE ‚¨ÖÔ∏è&#10;Perfect for beginners!" 
              color="#FFFFFF" 
              scale="0.8 0.8 0.8" 
              align="center"
              geometry="primitive: plane; width: 6; height: 2"
              material="color: #4CAF50; opacity: 0.15; transparent: true"></a-text>
      
      <a-text position="20 3 -10" 
              value="‚ö° EXTREME CHALLENGE ‚û°Ô∏è&#10;Master-level coordination!" 
              color="#FFFFFF" 
              scale="0.8 0.8 0.8" 
              align="center"
              geometry="primitive: plane; width: 6; height: 2"
              material="color: #E53935; opacity: 0.15; transparent: true"></a-text>
      
      <!-- Lighting -->
      <a-light type="ambient" color="#404040" intensity="0.5"></a-light>
      <a-light type="directional" color="#FFF8DC" intensity="1.2" position="20 30 15" 
               shadow="cast: true; mapSize: 2048 2048"></a-light>
      <a-light type="point" color="#FFE4B5" intensity="0.4" position="0 12 0"></a-light>
      
      <!-- VR Camera Rig -->
      <a-entity id="rig" position="0 1.6 18">
        <a-camera id="camera" 
                  look-controls="enabled: true" 
                  wasd-controls="enabled: true">
          <a-cursor id="gaze-cursor-vr" 
                    position="0 0 -1"
                    geometry="primitive: ring; radiusInner: 0.02; radiusOuter: 0.03"
                    material="color: #FFD700; opacity: 0.8"
                    animation__click="property: scale; startEvents: click; dur: 150; from: 0.1 0.1 0.1; to: 1 1 1"
                    animation__fusing="property: scale; startEvents: fusing; dur: 1500; from: 1 1 1; to: 0.1 0.1 0.1"
                    animation__mouseleave="property: scale; startEvents: mouseleave; dur: 500; to: 1 1 1"
                    raycaster="objects: .gazeable, .touchable"
                    fuse="true"
                    fuseTimeout="2000">
          </a-cursor>
        </a-camera>
      </a-entity>
      
    </a-scene>

    <script>
      // =====================================
      // FINAL FIXED THERAPEUTIC GOLF SYSTEM
      // =====================================
      
      // Global variables
      let esp32WebSocket = null;
      let therapeuticGolf = null;
      let sessionTimer = null;
      let gameState = 'menu';
      let lastSensorData = null;
      let debugMode = false;
      
      // OPTIMIZED MOVEMENT SYSTEM
      let movementSystem = {
        isActive: false,
        currentSpeed: 0,
        targetSpeed: 0,
        smoothing: 0.15,
        minSpeed: 0.01,
        maxSpeed: 0.8,
        lastUpdateTime: 0,
        frameInterval: 16,
        velocityBuffer: [],
        bufferSize: 3
      };
      
      // GOLF SYSTEM: Separate states for clear control
      let golfState = 'none'; // 'none', 'aiming', 'power'
      let golfPower = 0;
      let golfPowerDirection = 1;
      let golfTargetBall = null;
      let lastActionTime = 0;
      let actionCooldown = 500; // Increased cooldown
      let isInVRMode = false;
      let golfTimeout = null; // Golf timeout to prevent getting stuck
      
      // SENSOR THRESHOLD SYSTEM - ABSOLUTELY NO AUTO-COLLECTION
      let sensorThresholds = {
        flexThreshold: 60,  // MUCH HIGHER to prevent any auto-collection
        imuThreshold: 15,   // MUCH HIGHER to prevent auto-movement  
        proximityDistance: 2.5, // REDUCED for very deliberate actions
        flexRequired: false,  // Track if flex is actually being held
        imuRequired: false    // Track if IMU is actually being held
      };
      
      // Enhanced sensor data tracking
      let sensorDataHistory = {
        flex1: [],
        flex2: [],
        flex3: [],
        imuTilt: [],
        timestamps: [],
        reactionTimes: [],
        actionEvents: []
      };

      // Baseline sensor values
      let baselineValues = {
        flex1: 0,
        flex2: 0,
        flex3: 0,
        imuTilt: 0,
        captured: false
      };

      // Performance tracking
      let performanceMetrics = {
        activeTime: 0,
        idleTime: 0,
        lastActivityTime: Date.now(),
        totalActions: 0,
        successfulActions: 0,
        missedCues: 0
      };

      // ESP32 Connection
      function connectESP32() {
        console.log('üîò Connect button clicked!');
        
        const ipInput = document.getElementById('esp-ip');
        const statusDiv = document.getElementById('connection-status');
        const espStatus = document.getElementById('esp-status');
        
        const ip = ipInput ? ipInput.value.trim() : '192.168.0.129';
        
        if (!ip) {
          statusDiv.textContent = '‚ùå Please enter IP address';
          return;
        }
        
        console.log('üîó Connecting to:', ip);
        statusDiv.textContent = `Connecting to ${ip}...`;
        statusDiv.style.color = '#FFD700';
        
        if (esp32WebSocket) {
          esp32WebSocket.close();
        }
        
        esp32WebSocket = new WebSocket(`ws://${ip}:81/`);
        
        esp32WebSocket.onopen = () => {
          console.log('‚úÖ WebSocket Connected!');
          statusDiv.textContent = 'üü¢ Connected successfully!';
          statusDiv.style.color = '#4CAF50';
          espStatus.textContent = 'üì° ESP32: Connected';
          espStatus.className = 'esp-status';
        };
        
        esp32WebSocket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            lastSensorData = data;
            processFixedSensorData(data);
          } catch (e) {
            console.log('Raw data:', event.data);
          }
        };
        
        esp32WebSocket.onclose = () => {
          console.log('‚ùå WebSocket Closed');
          statusDiv.textContent = 'üî¥ Disconnected';
          statusDiv.style.color = '#F44336';
          espStatus.textContent = 'üì° ESP32: Disconnected';
          espStatus.className = 'esp-status disconnected';
        };
        
        esp32WebSocket.onerror = (error) => {
          console.error('‚ùå WebSocket Error:', error);
          statusDiv.textContent = '‚ö†Ô∏è Connection Error';
          statusDiv.style.color = '#F44336';
          espStatus.textContent = 'üì° ESP32: Error';
          espStatus.className = 'esp-status disconnected';
        };
      }

      // =====================================
      // FINALLY FIXED SENSOR PROCESSING - NO AUTO-COLLECTION!
      // =====================================
      function processFixedSensorData(data) {
        if (gameState !== 'playing' && gameState !== 'demo') return;
        
        const { flex, tilt, flexSolenoid, imuSolenoid } = data;
        if (!flex || tilt === undefined) return;
        
        const now = Date.now();
        const timestamp = (now - (therapeuticGolf?.sessionData?.startTime?.getTime() || now)) / 1000;
        const avgFlex = (flex[0] + flex[1] + flex[2]) / 3;
        const absTilt = Math.abs(tilt);
        
        // Store sensor data for analysis (optimized)
        if (sensorDataHistory.timestamps.length % 5 === 0) {
          sensorDataHistory.flex1.push(flex[0] || 0);
          sensorDataHistory.flex2.push(flex[1] || 0);
          sensorDataHistory.flex3.push(flex[2] || 0);
          sensorDataHistory.imuTilt.push(absTilt);
          sensorDataHistory.timestamps.push(timestamp);
        }
        
        // Capture baseline values in first 3 seconds
        if (!baselineValues.captured && timestamp < 3) {
          if (sensorDataHistory.flex1.length === 1) {
            baselineValues.flex1 = flex[0] || 0;
            baselineValues.flex2 = flex[1] || 0;
            baselineValues.flex3 = flex[2] || 0;
            baselineValues.imuTilt = absTilt;
            baselineValues.captured = true;
            console.log('üìä Baseline values captured:', baselineValues);
          }
        }
        
        // Track activity
        performanceMetrics.lastActivityTime = now;
        
        // STRICT SENSOR STATES - MUCH HIGHER THRESHOLDS
        const flexActive = (flexSolenoid === true) || (avgFlex >= sensorThresholds.flexThreshold);
        const imuActive = (imuSolenoid === true) || (absTilt >= sensorThresholds.imuThreshold);
        
        sensorThresholds.flexRequired = flexActive;
        sensorThresholds.imuRequired = imuActive;
        
        console.log(`üîß FINAL FIX - Sensor States - Flex: ${flexActive ? 'ACTIVE' : 'inactive'} (${avgFlex.toFixed(1)}/${sensorThresholds.flexThreshold}), IMU: ${imuActive ? 'ACTIVE' : 'inactive'} (${absTilt.toFixed(1)}/${sensorThresholds.imuThreshold}), Golf: ${golfState}`);
        
        // MOVEMENT: Only when IMU is deliberately activated AND not in golf mode
        if (imuActive && golfState === 'none') {
          const tiltIntensity = Math.min(absTilt / 25, 1.0);
          const targetSpeed = 0.2 + (tiltIntensity * 0.4);
          updateSmoothMovement(targetSpeed);
          
          performanceMetrics.totalActions++;
          
          // Track movement action (optimized)
          if (sensorDataHistory.actionEvents.length % 10 === 0) {
            sensorDataHistory.actionEvents.push({
              type: 'movement',
              timestamp: timestamp,
              flex: avgFlex,
              tilt: absTilt
            });
          }
        } else {
          // Stop movement when IMU not active
          updateSmoothMovement(0);
        }
        
        // Prevent rapid actions
        if ((now - lastActionTime) < actionCooldown) {
          return;
        }
        
        // ABSOLUTELY NO AUTO-COLLECTION - ONLY when finger is ACTIVELY flexed AND within proximity
        if (flexActive && golfState === 'none') {
          let success = false;
          
          console.log('ü§è DELIBERATE finger flex detected - checking proximity for collection/touch');
          
          // STRICT: Must be both flexing AND very close
          if (handleStrictProximityCollection()) {
            success = true;
            performanceMetrics.successfulActions++;
            console.log('üí∞ SUCCESS: Coin collected via deliberate flex + proximity');
          }
          
          // Try animal touch if no coin collected
          if (!success && handleStrictProximityTouch()) {
            success = true;
            performanceMetrics.successfulActions++;
            console.log('üêæ SUCCESS: Animal touched via deliberate flex + proximity');
          }
          
          if (success) {
            performanceMetrics.totalActions++;
            
            sensorDataHistory.actionEvents.push({
              type: 'pickup_touch',
              timestamp: timestamp,
              flex: avgFlex,
              tilt: absTilt
            });
          } else {
            performanceMetrics.missedCues++;
            console.log('‚ùå MISS: No valid target in strict proximity for deliberate flex');
          }
          
          lastActionTime = now;
        }
        
        // GOLF SYSTEM: Separate from other actions
        handleGolfSystem(avgFlex, absTilt, flexActive, imuActive, timestamp);
      }

      // =====================================
      // SMOOTH MOVEMENT SYSTEM
      // =====================================
      function updateSmoothMovement(targetSpeed) {
        const now = Date.now();
        
        // Frame rate limiting for consistent performance
        if (now - movementSystem.lastUpdateTime < movementSystem.frameInterval) {
          return;
        }
        
        movementSystem.lastUpdateTime = now;
        movementSystem.targetSpeed = Math.max(0, Math.min(targetSpeed, movementSystem.maxSpeed));
        
        // Smooth interpolation
        const speedDiff = movementSystem.targetSpeed - movementSystem.currentSpeed;
        movementSystem.currentSpeed += speedDiff * movementSystem.smoothing;
        
        // Apply movement if above minimum threshold
        if (movementSystem.currentSpeed > movementSystem.minSpeed) {
          executePlayerMovement(movementSystem.currentSpeed);
          movementSystem.isActive = true;
        } else {
          movementSystem.isActive = false;
        }
      }

      function executePlayerMovement(speed) {
        const rig = document.querySelector('#rig');
        const camera = document.querySelector('#camera');
        
        if (!rig || !camera) return;
        
        // Get current camera rotation and rig position
        const rotation = camera.getAttribute('rotation');
        const position = rig.getAttribute('position');
        
        // Calculate movement direction based on camera rotation
        const radians = (rotation.y * Math.PI) / 180;
        const deltaX = -Math.sin(radians) * speed;
        const deltaZ = -Math.cos(radians) * speed;
        
        // Apply movement with boundary checking
        const newPosition = {
          x: position.x + deltaX,
          y: position.y,
          z: position.z + deltaZ
        };
        
        // Boundary check - keep within 65 unit radius
        const distance = Math.sqrt(newPosition.x * newPosition.x + newPosition.z * newPosition.z);
        if (distance < 65) {
          // Use A-Frame's setAttribute for smooth updates
          rig.setAttribute('position', newPosition);
          
          // Update game metrics
          if (therapeuticGolf) {
            therapeuticGolf.sessionData.explorationDistance += speed;
            therapeuticGolf.sessionData.totalDistance += speed;
            
            // Update HUD less frequently for better performance
            if (Math.random() < 0.1) {
              updateHUD();
            }
          }
        }
      }

      // =====================================
      // COMPLETELY FIXED GOLF SYSTEM - NO MORE GETTING STUCK!
      // =====================================
      function handleGolfSystem(avgFlex, absTilt, flexActive, imuActive, timestamp) {
        const isLookingAtBall = checkGolfBallGaze();
        
        switch (golfState) {
          case 'none':
            // Enter golf mode: Look at ball + hold finger flex
            if (isLookingAtBall && flexActive) {
              enterGolfAiming(isLookingAtBall.ball);
            }
            break;
            
          case 'aiming':
            // Continue aiming: Keep finger flex held
            if (flexActive) {
              // Start power meter: Add elbow movement
              if (imuActive) {
                startGolfPowerMeter();
              }
            } else {
              // Released finger - FORCE cancel golf and return to normal mode
              forceExitGolf('finger released during aiming');
            }
            break;
            
          case 'power':
            // Building power: Keep both finger + elbow
            if (flexActive && imuActive) {
              updateGolfPower();
            } else {
              // Released either control - swing!
              executeGolfSwing(timestamp);
            }
            break;
        }
      }

      function checkGolfBallGaze() {
        const camera = document.querySelector('#camera');
        const raycaster = camera.querySelector('#gaze-cursor-vr').components.raycaster;
        
        if (raycaster && raycaster.intersectedEls.length > 0) {
          const intersected = raycaster.intersectedEls[0];
          if (intersected.classList.contains('golf-ball')) {
            return { ball: intersected };
          }
        }
        return null;
      }

      function enterGolfAiming(ball) {
        golfState = 'aiming';
        golfTargetBall = ball;
        updateModeIndicator();
        console.log('üèåÔ∏è Entered golf aiming mode');
        
        // Set timeout to prevent getting stuck in golf mode
        if (golfTimeout) clearTimeout(golfTimeout);
        golfTimeout = setTimeout(() => {
          console.log('‚è∞ Golf timeout - forcing exit from aiming mode');
          forceExitGolf('timeout during aiming');
        }, 10000); // 10 second timeout
        
        // Visual feedback
        ball.setAttribute('animation__glow', {
          property: 'material.emissiveIntensity',
          to: '0.8',
          dur: 500,
          dir: 'alternate',
          loop: true
        });
      }

      function startGolfPowerMeter() {
        golfState = 'power';
        golfPower = 0;
        golfPowerDirection = 1;
        
        // Show power meter
        document.getElementById('golf-power-meter').style.display = 'block';
        updateModeIndicator();
        console.log('‚ö° Golf power meter started');
        
        // Reset timeout for power mode
        if (golfTimeout) clearTimeout(golfTimeout);
        golfTimeout = setTimeout(() => {
          console.log('‚è∞ Golf timeout - forcing swing from power mode');
          executeGolfSwing(Date.now());
        }, 8000); // 8 second timeout for power mode
      }

      function updateGolfPower() {
        golfPower += golfPowerDirection * 3;
        
        if (golfPower >= 100) {
          golfPower = 100;
          golfPowerDirection = -1;
        } else if (golfPower <= 0) {
          golfPower = 0;
          golfPowerDirection = 1;
        }
        
        document.getElementById('power-meter-fill').style.width = golfPower + '%';
      }

      function executeGolfSwing(timestamp) {
        if (!golfTargetBall) {
          forceExitGolf('no target ball during swing');
          return;
        }
        
        console.log(`üèåÔ∏è Golf swing executed with ${golfPower}% power!`);
        
        // Clear timeout immediately
        if (golfTimeout) {
          clearTimeout(golfTimeout);
          golfTimeout = null;
        }
        
        // Hide power meter
        document.getElementById('golf-power-meter').style.display = 'none';
        
        // Calculate ball trajectory based on power
        const power = golfPower / 100;
        const ballPos = golfTargetBall.getAttribute('position');
        const ballParent = golfTargetBall.parentEl.getAttribute('position');
        
        // Determine which course and hole
        const isEasy = Math.abs(ballParent.x + 20) < Math.abs(ballParent.x - 20);
        const holePos = {
          x: ballParent.x + 0,
          y: 0,
          z: ballParent.z + 3
        };
        
        // Calculate target with power and accuracy
        const accuracy = 1 - (Math.abs(power - 0.7) * 2);
        const spread = (1 - accuracy) * 8;
        
        const targetX = holePos.x + (Math.random() - 0.5) * spread;
        const targetZ = holePos.z + (Math.random() - 0.5) * spread;
        const height = 1 + power * 3;
        
        // Animate ball
        golfTargetBall.setAttribute('animation__swing', {
          property: 'position',
          to: `${targetX} ${height} ${targetZ}`,
          dur: 1500 + power * 1000
        });
        
        // Track shot
        if (therapeuticGolf) {
          therapeuticGolf.sessionData.totalShots++;
          updateHUD();
        }
        
        // Track golf swing action
        sensorDataHistory.actionEvents.push({
          type: 'golf_swing',
          timestamp: timestamp,
          flex: avgFlex,
          tilt: absTilt,
          power: golfPower
        });
        
        performanceMetrics.totalActions++;
        
        // FORCE EXIT golf mode immediately after swing
        forceExitGolf('swing completed');
        
        // Check for success after ball lands and ALWAYS reset ball
        const landingTime = 2500 + power * 1000;
        setTimeout(() => {
          checkGolfSuccess(targetX, targetZ, holePos, isEasy);
          forcedResetGolfBallToTee(isEasy); // GUARANTEED reset
        }, landingTime);
      }

      function checkGolfSuccess(ballX, ballZ, holePos, isEasy) {
        const distance = Math.sqrt(
          Math.pow(ballX - holePos.x, 2) + 
          Math.pow(ballZ - holePos.z, 2)
        );
        
        const successRadius = isEasy ? 2.5 : 2.0;
        
        console.log(`‚õ≥ Ball distance from flag: ${distance.toFixed(1)}m (success radius: ${successRadius}m)`);
        
        if (distance <= successRadius) {
          console.log('üéØ SUCCESS! Ball reached the flag!');
          
          if (therapeuticGolf) {
            therapeuticGolf.sessionData.successfulShots++;
            updateHUD();
          }
          
          performanceMetrics.successfulActions++;
          
          // Success celebration
          const flagZone = document.getElementById(isEasy ? 'easy-flag-zone' : 'challenging-flag-zone');
          if (flagZone) {
            flagZone.setAttribute('animation__success', {
              property: 'material.opacity',
              to: '0.8',
              dur: 1000,
              dir: 'alternate',
              loop: 3
            });
          }
          
          console.log('üèÜ Shot counted as successful!');
        } else {
          console.log('‚ùå Shot missed the flag');
        }
      }

      // GUARANTEED ball reset function - NO FAILURE POSSIBLE
      function forcedResetGolfBallToTee(isEasy) {
        console.log(`üîÑ FORCED reset of ${isEasy ? 'easy' : 'challenging'} ball to tee...`);
        
        const ballId = isEasy ? 'easy-ball' : 'challenging-ball';
        const ball = document.getElementById(ballId);
        
        if (ball) {
          // Remove ALL animations
          ball.removeAttribute('animation__glow');
          ball.removeAttribute('animation__swing');
          ball.removeAttribute('animation');
          
          // FORCE reset to original tee position
          const originalPos = isEasy ? { x: 0, y: 0.2, z: 12 } : { x: 0, y: 0.35, z: 15 };
          
          // Multiple forced resets to ensure it works
          ball.setAttribute('position', originalPos);
          ball.setAttribute('scale', '1 1 1');
          ball.setAttribute('rotation', '0 0 0');
          
          // Force another reset after a delay to be absolutely sure
          setTimeout(() => {
            ball.setAttribute('position', originalPos);
            ball.setAttribute('scale', '1 1 1');
            ball.setAttribute('rotation', '0 0 0');
            console.log(`‚úÖ Ball GUARANTEED reset to: ${originalPos.x} ${originalPos.y} ${originalPos.z}`);
          }, 500);
          
        } else {
          console.error(`‚ùå Could not find ball with ID: ${ballId}`);
        }
      }

      // FORCE EXIT golf mode - NO GETTING STUCK
      function forceExitGolf(reason) {
        console.log(`‚ùå FORCE EXITING golf mode - Reason: ${reason}`);
        
        // Clear timeout
        if (golfTimeout) {
          clearTimeout(golfTimeout);
          golfTimeout = null;
        }
        
        // Reset all golf states
        golfState = 'none';
        golfTargetBall = null;
        golfPower = 0;
        golfPowerDirection = 1;
        
        // Hide power meter
        document.getElementById('golf-power-meter').style.display = 'none';
        
        // Remove any glow animations from balls
        const easyBall = document.getElementById('easy-ball');
        const challengingBall = document.getElementById('challenging-ball');
        if (easyBall) easyBall.removeAttribute('animation__glow');
        if (challengingBall) challengingBall.removeAttribute('animation__glow');
        
        // Update mode indicator
        updateModeIndicator();
        
        console.log('‚úÖ Golf mode FORCEFULLY exited - back to normal mode');
      }

      // Update mode indicator
      function updateModeIndicator() {
        const indicator = document.getElementById('mode-indicator');
        if (!indicator) return;
        
        switch (golfState) {
          case 'aiming':
            indicator.className = 'mode-indicator golf-ready';
            indicator.innerHTML = `
              <div><strong>üéØ GOLF AIMING</strong></div>
              <div style="font-size: 12px; margin-top: 5px;">Keep finger flex + add elbow for power</div>
              <div style="font-size: 12px;">Release finger to cancel</div>
            `;
            break;
            
          case 'power':
            indicator.className = 'mode-indicator golf-ready';
            indicator.innerHTML = `
              <div><strong>‚ö° GOLF POWER</strong></div>
              <div style="font-size: 12px; margin-top: 5px;">Hold both controls for power</div>
              <div style="font-size: 12px;">Release either to swing!</div>
            `;
            break;
            
          default:
            indicator.className = 'mode-indicator walk-mode';
            indicator.innerHTML = `
              <div><strong>üö∂ FIXED: NO AUTO-COLLECT</strong></div>
              <div style="font-size: 12px; margin-top: 5px;">Elbow = move, MUST flex finger + be close</div>
              <div style="font-size: 12px;">Look at ball + flex finger for golf</div>
            `;
            break;
        }
      }

      // ABSOLUTELY NO AUTO-COLLECTION - Must be both flexing AND in proximity
      function handleStrictProximityCollection() {
        const coins = document.querySelectorAll('.assessment-coin');
        const rigPos = document.querySelector('#rig').getAttribute('position');
        
        console.log(`üîç Checking ${coins.length} coins for STRICT proximity + flex collection...`);
        
        let collected = false;
        coins.forEach((coin) => {
          if (coin.parentNode && !collected) {
            const coinPos = coin.getAttribute('position');
            const distance = Math.sqrt(
              Math.pow(rigPos.x - coinPos.x, 2) + 
              Math.pow(rigPos.z - coinPos.z, 2)
            );
            
            console.log(`üí∞ Coin distance: ${distance.toFixed(1)}m (must be < ${sensorThresholds.proximityDistance}m + finger flexed)`);
            
            // ABSOLUTELY STRICT: Must be BOTH flexing AND very close
            if (distance < sensorThresholds.proximityDistance) {
              console.log('üí∞ ‚úÖ Coin collected - BOTH flex active AND in proximity');
              collectCoin(coin);
              collected = true;
            } else {
              console.log(`üí∞ ‚ùå Coin too far: ${distance.toFixed(1)}m > ${sensorThresholds.proximityDistance}m`);
            }
          }
        });
        
        return collected;
      }

      // ABSOLUTELY NO AUTO-TOUCH - Must be both flexing AND in proximity
      function handleStrictProximityTouch() {
        const animals = document.querySelectorAll('.touchable');
        const rigPos = document.querySelector('#rig').getAttribute('position');
        
        console.log(`üîç Checking ${animals.length} animals for STRICT proximity + flex touch...`);
        
        let touched = false;
        animals.forEach((animal) => {
          if (!touched) {
            const animalPos = animal.getAttribute('position');
            const distance = Math.sqrt(
              Math.pow(rigPos.x - animalPos.x, 2) + 
              Math.pow(rigPos.z - animalPos.z, 2)
            );
            
            console.log(`üêæ Animal distance: ${distance.toFixed(1)}m (must be < ${sensorThresholds.proximityDistance}m + finger flexed)`);
            
            // ABSOLUTELY STRICT: Must be BOTH flexing AND very close
            if (distance < sensorThresholds.proximityDistance) {
              console.log('üêæ ‚úÖ Animal touched - BOTH flex active AND in proximity');
              touchAnimal(animal);
              touched = true;
            } else {
              console.log(`üêæ ‚ùå Animal too far: ${distance.toFixed(1)}m > ${sensorThresholds.proximityDistance}m`);
            }
          }
        });
        
        return touched;
      }

      // =====================================
      // SESSION MANAGEMENT
      // =====================================
      
      function startSession() {
        const patientName = document.getElementById('patient-name').value.trim();
        const patientId = document.getElementById('patient-id').value.trim();
        
        if (!patientName || !patientId) {
          alert('Please enter patient name and ID before starting the session.');
          return;
        }
        
        initializeTherapeuticGolf(patientName, patientId);
        
        // Reset all states
        forceExitGolf('session start');
        movementSystem.currentSpeed = 0;
        movementSystem.targetSpeed = 0;
        movementSystem.isActive = false;
        sensorThresholds.flexRequired = false;
        sensorThresholds.imuRequired = false;
        
        document.getElementById('game-overlay').classList.add('hidden');
        document.getElementById('session-timer').style.display = 'block';
        document.getElementById('performance-hud').style.display = 'block';
        document.getElementById('mode-indicator').style.display = 'block';
        
        gameState = 'playing';
        startSessionTimer();
        
        // Clear sensor history and reset metrics
        sensorDataHistory = {
          flex1: [], flex2: [], flex3: [], imuTilt: [],
          timestamps: [], reactionTimes: [], actionEvents: []
        };
        baselineValues = { flex1: 0, flex2: 0, flex3: 0, imuTilt: 0, captured: false };
        performanceMetrics = { 
          activeTime: 0, idleTime: 0, lastActivityTime: Date.now(),
          totalActions: 0, successfulActions: 0, missedCues: 0 
        };
        
        setTimeout(() => {
          initializeScatteredFlowers();
          spawnAssessmentCoins();
        }, 1000);
      }

      function startDemo() {
        // Reset all states
        forceExitGolf('demo start');
        movementSystem.currentSpeed = 0;
        movementSystem.targetSpeed = 0;
        movementSystem.isActive = false;
        sensorThresholds.flexRequired = false;
        sensorThresholds.imuRequired = false;
        
        // Create dummy therapeutic golf object for demo
        therapeuticGolf = {
          sessionData: {
            patientName: 'Demo User',
            patientId: 'DEMO',
            startTime: new Date(),
            totalShots: 0,
            successfulShots: 0,
            coinsCollected: 0,
            animalInteractions: 0,
            explorationDistance: 0,
            totalDistance: 0,
            flowersDiscovered: 0,
            sessionCompleted: false
          }
        };
        
        updateModeIndicator();
        
        document.getElementById('game-overlay').classList.add('hidden');
        document.getElementById('session-timer').style.display = 'block';
        document.getElementById('performance-hud').style.display = 'block';
        document.getElementById('mode-indicator').style.display = 'block';
        
        gameState = 'demo';
        
        setTimeout(() => {
          initializeScatteredFlowers();
        }, 1000);
      }

      function newSession() {
        gameState = 'menu';
        forceExitGolf('new session');
        movementSystem.currentSpeed = 0;
        movementSystem.targetSpeed = 0;
        movementSystem.isActive = false;
        
        if (sessionTimer) {
          clearInterval(sessionTimer);
        }
        
        document.getElementById('results-dashboard').style.display = 'none';
        document.getElementById('game-overlay').classList.remove('hidden');
        document.getElementById('golf-power-meter').style.display = 'none';
        
        document.getElementById('patient-name').value = '';
        document.getElementById('patient-id').value = '';
        
        document.getElementById('session-timer').style.display = 'none';
        document.getElementById('performance-hud').style.display = 'none';
        document.getElementById('mode-indicator').style.display = 'none';
      }

      function initializeTherapeuticGolf(patientName, patientId) {
        therapeuticGolf = {
          sessionData: {
            patientName: patientName,
            patientId: patientId,
            startTime: new Date(),
            totalShots: 0,
            successfulShots: 0,
            coinsCollected: 0,
            animalInteractions: 0,
            explorationDistance: 0,
            totalDistance: 0,
            flowersDiscovered: 0,
            sessionCompleted: false
          }
        };
        
        console.log('üè• FINAL FIXED Therapeutic Golf System initialized - ZERO auto-collection!');
      }

      // Session timer
      function startSessionTimer() {
        let timeRemaining = 600; // 10 minutes
        const timerDisplay = document.getElementById('time-remaining');
        const progressBar = document.getElementById('session-progress');
        
        sessionTimer = setInterval(() => {
          timeRemaining--;
          
          const minutes = Math.floor(timeRemaining / 60);
          const seconds = timeRemaining % 60;
          timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          
          const progress = ((600 - timeRemaining) / 600) * 100;
          progressBar.style.width = `${progress}%`;
          
          // Track active/idle time
          const now = Date.now();
          if (now - performanceMetrics.lastActivityTime < 5000) {
            performanceMetrics.activeTime += 1;
          } else {
            performanceMetrics.idleTime += 1;
          }
          
          if (timeRemaining <= 0) {
            endSession();
          }
        }, 1000);
      }

      function endSession() {
        if (sessionTimer) {
          clearInterval(sessionTimer);
        }
        
        gameState = 'finished';
        forceExitGolf('session end');
        movementSystem.currentSpeed = 0;
        movementSystem.targetSpeed = 0;
        movementSystem.isActive = false;
        
        if (therapeuticGolf) {
          therapeuticGolf.sessionData.sessionCompleted = true;
        }
        
        document.getElementById('session-timer').style.display = 'none';
        document.getElementById('performance-hud').style.display = 'none';
        document.getElementById('mode-indicator').style.display = 'none';
        document.getElementById('golf-power-meter').style.display = 'none';
        
        showResults();
      }

      // =====================================
      // GAME INTERACTION FUNCTIONS
      // =====================================
      
      function collectCoin(coin) {
        if (!coin || !coin.parentNode || (gameState !== 'playing' && gameState !== 'demo')) return;
        
        coin.setAttribute('animation__collect', {
          property: 'position',
          to: `${coin.getAttribute('position').x} 3 ${coin.getAttribute('position').z}`,
          dur: 800
        });
        
        coin.setAttribute('animation__shrink', {
          property: 'scale',
          to: '0 0 0',
          dur: 800
        });
        
        setTimeout(() => {
          if (coin.parentNode) {
            coin.parentNode.removeChild(coin);
          }
        }, 800);
        
        if (therapeuticGolf) {
          therapeuticGolf.sessionData.coinsCollected++;
          updateHUD();
        }
        
        setTimeout(() => {
          if (gameState === 'playing') {
            spawnNewCoin();
          }
        }, 1500);
      }

      function touchAnimal(animal) {
        if (!animal || (gameState !== 'playing' && gameState !== 'demo')) return;
        
        animal.setAttribute('animation__touch', {
          property: 'scale',
          to: '1.1 1.1 1.1',
          dur: 300,
          dir: 'alternate',
          loop: 2
        });
        
        if (therapeuticGolf) {
          therapeuticGolf.sessionData.animalInteractions++;
          updateHUD();
        }
      }

      // =====================================
      // RESULTS AND CHARTS
      // =====================================
      
      function showResults() {
        const dashboard = document.getElementById('results-dashboard');
        dashboard.style.display = 'block';
        
        if (therapeuticGolf && sensorDataHistory.timestamps.length > 0) {
          const sessionData = therapeuticGolf.sessionData;
          
          // Populate session metadata
          document.getElementById('meta-patient-name').textContent = sessionData.patientName;
          document.getElementById('meta-patient-id').textContent = sessionData.patientId;
          document.getElementById('meta-date').textContent = sessionData.startTime.toLocaleDateString();
          document.getElementById('meta-duration').textContent = sessionData.sessionCompleted ? '10:00 minutes' : 'Incomplete';
          document.getElementById('meta-esp32-status').textContent = 
            esp32WebSocket && esp32WebSocket.readyState === WebSocket.OPEN ? 'Connected' : 'Disconnected';
          
          // Calculate metrics
          calculateFlexMetrics();
          calculateIMUMetrics();
          calculatePerformanceMetrics();
          generateCharts();
          
          console.log('üìä FINAL FIXED Results Dashboard populated');
        }
      }

      function calculateFlexMetrics() {
        const threshold = 25;
        
        if (sensorDataHistory.flex1.length === 0) return;
        
        // Flex 1 metrics
        const flex1Avg = sensorDataHistory.flex1.reduce((a, b) => a + b, 0) / sensorDataHistory.flex1.length;
        const flex1Peak = Math.max(...sensorDataHistory.flex1);
        const flex1Reps = sensorDataHistory.flex1.filter(val => val > threshold).length;
        
        document.getElementById('flex1-baseline').textContent = baselineValues.flex1.toFixed(1);
        document.getElementById('flex1-avg').textContent = flex1Avg.toFixed(1);
        document.getElementById('flex1-peak').textContent = flex1Peak.toFixed(1);
        document.getElementById('flex1-reps').textContent = flex1Reps;
        
        // Flex 2 metrics
        const flex2Avg = sensorDataHistory.flex2.reduce((a, b) => a + b, 0) / sensorDataHistory.flex2.length;
        const flex2Peak = Math.max(...sensorDataHistory.flex2);
        const flex2Reps = sensorDataHistory.flex2.filter(val => val > threshold).length;
        
        document.getElementById('flex2-baseline').textContent = baselineValues.flex2.toFixed(1);
        document.getElementById('flex2-avg').textContent = flex2Avg.toFixed(1);
        document.getElementById('flex2-peak').textContent = flex2Peak.toFixed(1);
        document.getElementById('flex2-reps').textContent = flex2Reps;
        
        // Flex 3 metrics
        const flex3Avg = sensorDataHistory.flex3.reduce((a, b) => a + b, 0) / sensorDataHistory.flex3.length;
        const flex3Peak = Math.max(...sensorDataHistory.flex3);
        const flex3Reps = sensorDataHistory.flex3.filter(val => val > threshold).length;
        
        document.getElementById('flex3-baseline').textContent = baselineValues.flex3.toFixed(1);
        document.getElementById('flex3-avg').textContent = flex3Avg.toFixed(1);
        document.getElementById('flex3-peak').textContent = flex3Peak.toFixed(1);
        document.getElementById('flex3-reps').textContent = flex3Reps;
      }

      function calculateIMUMetrics() {
        if (sensorDataHistory.imuTilt.length === 0) return;
        
        const imuAvg = sensorDataHistory.imuTilt.reduce((a, b) => a + b, 0) / sensorDataHistory.imuTilt.length;
        const imuMax = Math.max(...sensorDataHistory.imuTilt);
        const imuMin = Math.min(...sensorDataHistory.imuTilt);
        const imuRange = imuMax - imuMin;
        
        // Calculate stability index
        const imuVariance = sensorDataHistory.imuTilt.reduce((acc, val) => acc + Math.pow(val - imuAvg, 2), 0) / sensorDataHistory.imuTilt.length;
        const stabilityIndex = Math.max(0, 100 - (Math.sqrt(imuVariance) * 10));
        
        // Count repetitions
        const tiltThreshold = 8;
        const imuReps = sensorDataHistory.imuTilt.filter(val => val > tiltThreshold).length;
        
        document.getElementById('imu-baseline').textContent = baselineValues.imuTilt.toFixed(1) + '¬∞';
        document.getElementById('imu-max-rom').textContent = imuRange.toFixed(1) + '¬∞';
        document.getElementById('imu-avg').textContent = imuAvg.toFixed(1) + '¬∞';
        document.getElementById('imu-stability').textContent = stabilityIndex.toFixed(1) + '%';
        document.getElementById('imu-repetitions').textContent = imuReps;
      }

      function calculatePerformanceMetrics() {
        const totalTime = performanceMetrics.activeTime + performanceMetrics.idleTime;
        const successRate = performanceMetrics.totalActions > 0 ? 
          (performanceMetrics.successfulActions / performanceMetrics.totalActions * 100) : 0;
        const engagementRatio = totalTime > 0 ? (performanceMetrics.activeTime / totalTime * 100) : 0;
        
        // Calculate average reaction time
        let avgReactionTime = 250;
        if (sensorDataHistory.actionEvents.length > 1) {
          const intervals = [];
          for (let i = 1; i < sensorDataHistory.actionEvents.length; i++) {
            const interval = (sensorDataHistory.actionEvents[i].timestamp - sensorDataHistory.actionEvents[i-1].timestamp) * 1000;
            if (interval < 5000 && interval > 100) {
              intervals.push(interval);
            }
          }
          if (intervals.length > 0) {
            avgReactionTime = intervals.reduce((a, b) => a + b, 0) / intervals.length;
          }
        }
        
        document.getElementById('task-success-rate').textContent = successRate.toFixed(1) + '%';
        document.getElementById('missed-cues').textContent = performanceMetrics.missedCues;
        document.getElementById('avg-reaction-time').textContent = Math.round(avgReactionTime) + 'ms';
        document.getElementById('active-time').textContent = (performanceMetrics.activeTime / 60).toFixed(1) + 'min';
        document.getElementById('idle-time').textContent = (performanceMetrics.idleTime / 60).toFixed(1) + 'min';
        document.getElementById('engagement-ratio').textContent = engagementRatio.toFixed(1) + '%';
      }

      function generateCharts() {
        generateFlexWaveformChart();
        generateIMUTiltChart();
        generateEngagementPieChart();
        generateSuccessFailureChart();
      }

      function generateFlexWaveformChart() {
        const ctx = document.getElementById('flex-waveform-chart').getContext('2d');
        
        if (sensorDataHistory.timestamps.length === 0) return;
        
        // Sample data points for better performance
        const sampledTimestamps = sensorDataHistory.timestamps.filter((_, i) => i % 10 === 0);
        const sampledFlex1 = sensorDataHistory.flex1.filter((_, i) => i % 10 === 0);
        const sampledFlex2 = sensorDataHistory.flex2.filter((_, i) => i % 10 === 0);
        const sampledFlex3 = sensorDataHistory.flex3.filter((_, i) => i % 10 === 0);
        
        new Chart(ctx, {
          type: 'line',
          data: {
            labels: sampledTimestamps.map(t => (t / 60).toFixed(1) + 'm'),
            datasets: [
              {
                label: 'Flex Sensor 1',
                data: sampledFlex1,
                borderColor: '#FF6384',
                backgroundColor: 'rgba(255, 99, 132, 0.1)',
                borderWidth: 2,
                fill: false
              },
              {
                label: 'Flex Sensor 2',
                data: sampledFlex2,
                borderColor: '#36A2EB',
                backgroundColor: 'rgba(54, 162, 235, 0.1)',
                borderWidth: 2,
                fill: false
              },
              {
                label: 'Flex Sensor 3',
                data: sampledFlex3,
                borderColor: '#4BC0C0',
                backgroundColor: 'rgba(75, 192, 192, 0.1)',
                borderWidth: 2,
                fill: false
              }
            ]
          },
          options: {
            responsive: true,
            scales: {
              x: { title: { display: true, text: 'Time (minutes)' } },
              y: { title: { display: true, text: 'Flex Value (ADC)' } }
            },
            plugins: {
              title: { display: true, text: 'Finger Bending Cycles - FINAL FIX (No Auto-Collection)' }
            }
          }
        });
      }

      function generateIMUTiltChart() {
        const ctx = document.getElementById('imu-tilt-chart').getContext('2d');
        
        if (sensorDataHistory.timestamps.length === 0) return;
        
        const sampledTimestamps = sensorDataHistory.timestamps.filter((_, i) => i % 10 === 0);
        const sampledIMU = sensorDataHistory.imuTilt.filter((_, i) => i % 10 === 0);
        
        new Chart(ctx, {
          type: 'line',
          data: {
            labels: sampledTimestamps.map(t => (t / 60).toFixed(1) + 'm'),
            datasets: [
              {
                label: 'IMU Tilt Angle',
                data: sampledIMU,
                borderColor: '#FF9F40',
                backgroundColor: 'rgba(255, 159, 64, 0.1)',
                borderWidth: 2,
                fill: true
              }
            ]
          },
          options: {
            responsive: true,
            scales: {
              x: { title: { display: true, text: 'Time (minutes)' } },
              y: { title: { display: true, text: 'Tilt Angle (degrees)' } }
            },
            plugins: {
              title: { display: true, text: 'Elbow Range of Motion - FINAL FIX (No Auto-Movement)' }
            }
          }
        });
      }

      function generateEngagementPieChart() {
        const ctx = document.getElementById('engagement-pie-chart').getContext('2d');
        
        new Chart(ctx, {
          type: 'pie',
          data: {
            labels: ['Active Time', 'Idle Time'],
            datasets: [{
              data: [performanceMetrics.activeTime, performanceMetrics.idleTime],
              backgroundColor: ['#4CAF50', '#FFC107']
            }]
          },
          options: {
            responsive: true,
            plugins: {
              title: { display: true, text: 'Session Engagement Distribution - FINAL FIX' },
              legend: { position: 'bottom' }
            }
          }
        });
      }

      function generateSuccessFailureChart() {
        const ctx = document.getElementById('success-failure-chart').getContext('2d');
        
        new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: ['Successful Actions', 'Failed Attempts'],
            datasets: [{
              data: [performanceMetrics.successfulActions, performanceMetrics.missedCues],
              backgroundColor: ['#4CAF50', '#F44336']
            }]
          },
          options: {
            responsive: true,
            plugins: {
              title: { display: true, text: 'Task Performance - FINAL FIX (No Auto-Actions)' },
              legend: { position: 'bottom' }
            }
          }
        });
      }

      // Update HUD display
      function updateHUD() {
        if (!therapeuticGolf || (gameState !== 'playing' && gameState !== 'demo')) return;
        
        document.getElementById('shot-count').textContent = therapeuticGolf.sessionData.totalShots;
        document.getElementById('accuracy').textContent = 
          therapeuticGolf.sessionData.totalShots > 0 ? 
          Math.round((therapeuticGolf.sessionData.successfulShots / therapeuticGolf.sessionData.totalShots) * 100) + '%' : '0%';
        document.getElementById('current-score').textContent = 
          (therapeuticGolf.sessionData.successfulShots * 10) + 
          (therapeuticGolf.sessionData.coinsCollected * 5) + 
          (therapeuticGolf.sessionData.animalInteractions * 8);
        document.getElementById('exploration-distance').textContent = Math.round(therapeuticGolf.sessionData.explorationDistance) + 'm';
      }

      // =====================================
      // EXPORT FUNCTIONS
      // =====================================
      
      function exportPDF() {
        if (!therapeuticGolf) {
          alert('No session data to export');
          return;
        }
        
        const sessionData = therapeuticGolf.sessionData;
        const flex1Avg = sensorDataHistory.flex1.length > 0 ? 
          sensorDataHistory.flex1.reduce((a, b) => a + b, 0) / sensorDataHistory.flex1.length : 0;
        const flex2Avg = sensorDataHistory.flex2.length > 0 ?
          sensorDataHistory.flex2.reduce((a, b) => a + b, 0) / sensorDataHistory.flex2.length : 0;
        const flex3Avg = sensorDataHistory.flex3.length > 0 ?
          sensorDataHistory.flex3.reduce((a, b) => a + b, 0) / sensorDataHistory.flex3.length : 0;
        const imuAvg = sensorDataHistory.imuTilt.length > 0 ?
          sensorDataHistory.imuTilt.reduce((a, b) => a + b, 0) / sensorDataHistory.imuTilt.length : 0;
        const successRate = performanceMetrics.totalActions > 0 ? 
          (performanceMetrics.successfulActions / performanceMetrics.totalActions * 100) : 0;
        
        const reportData = `
VR THERAPEUTIC GOLF ASSESSMENT - FINAL FIXED VERSION REPORT
==========================================================

FINAL FIXES IMPLEMENTED:
- ‚úÖ FINAL FIX: ZERO auto-collection (flex threshold: ${sensorThresholds.flexThreshold})
- ‚úÖ FINAL FIX: ZERO auto-touch (proximity required: ${sensorThresholds.proximityDistance}m)  
- ‚úÖ FINAL FIX: Golf NEVER gets stuck (forced timeouts + exits)
- ‚úÖ FINAL FIX: Golf ball ALWAYS returns to tee (guaranteed reset)
- ‚úÖ FINAL FIX: Higher thresholds prevent accidental triggers

SESSION METADATA:
- Patient Name: ${sessionData.patientName}
- Patient ID: ${sessionData.patientId}
- Assessment Date: ${sessionData.startTime.toLocaleDateString()}
- Session Duration: ${sessionData.sessionCompleted ? '10:00 minutes' : 'Incomplete'}
- Task/Game: VR Therapeutic Golf Assessment (FINAL FIXED VERSION)
- ESP32 Status: ${esp32WebSocket && esp32WebSocket.readyState === WebSocket.OPEN ? 'Connected' : 'Disconnected'}

FINAL FIXED CONTROL THRESHOLDS:
- Flex Threshold: ${sensorThresholds.flexThreshold} (much higher to prevent auto-collection)
- IMU Threshold: ${sensorThresholds.imuThreshold} (much higher to prevent auto-movement)
- Proximity Distance: ${sensorThresholds.proximityDistance}m (reduced for deliberate actions only)
- Action Cooldown: ${actionCooldown}ms (prevents rapid triggering)

FLEX SENSOR RESULTS:
- Flex 1: Baseline=${baselineValues.flex1.toFixed(1)}, Avg=${flex1Avg.toFixed(1)}, Peak=${sensorDataHistory.flex1.length > 0 ? Math.max(...sensorDataHistory.flex1).toFixed(1) : '0'}
- Flex 2: Baseline=${baselineValues.flex2.toFixed(1)}, Avg=${flex2Avg.toFixed(1)}, Peak=${sensorDataHistory.flex2.length > 0 ? Math.max(...sensorDataHistory.flex2).toFixed(1) : '0'}
- Flex 3: Baseline=${baselineValues.flex3.toFixed(1)}, Avg=${flex3Avg.toFixed(1)}, Peak=${sensorDataHistory.flex3.length > 0 ? Math.max(...sensorDataHistory.flex3).toFixed(1) : '0'}

IMU RESULTS:
- Baseline Tilt: ${baselineValues.imuTilt.toFixed(1)}¬∞
- Average Tilt: ${imuAvg.toFixed(1)}¬∞
- Max ROM: ${sensorDataHistory.imuTilt.length > 0 ? (Math.max(...sensorDataHistory.imuTilt) - Math.min(...sensorDataHistory.imuTilt)).toFixed(1) : '0'}¬∞
- Repetitions: ${sensorDataHistory.imuTilt.filter(val => val > 8).length}

PERFORMANCE & ENGAGEMENT:
- Task Success Rate: ${successRate.toFixed(1)}%
- Missed Cues: ${performanceMetrics.missedCues}
- Active Time: ${(performanceMetrics.activeTime / 60).toFixed(1)} minutes
- Idle Time: ${(performanceMetrics.idleTime / 60).toFixed(1)} minutes
- Engagement Ratio: ${((performanceMetrics.activeTime / (performanceMetrics.activeTime + performanceMetrics.idleTime)) * 100).toFixed(1)}%

GAME PERFORMANCE:
- Golf Shots: ${sessionData.totalShots}
- Successful Shots: ${sessionData.successfulShots}
- Coins Collected: ${sessionData.coinsCollected} (FINAL FIX: NO AUTO-COLLECTION)
- Animal Interactions: ${sessionData.animalInteractions} (FINAL FIX: NO AUTO-TOUCH)
- Distance Traveled: ${Math.round(sessionData.totalDistance)}m

CLINICAL NOTES:
${document.getElementById('physician-notes').value || 'No clinical notes provided'}

Report generated: ${new Date().toLocaleString()}
FINAL FIXED VERSION - All major issues permanently resolved
        `;
        
        const blob = new Blob([reportData], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `VR_Golf_FINAL_FIXED_Report_${sessionData.patientId}_${new Date().toISOString().split('T')[0]}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function exportCSV() {
        if (!therapeuticGolf || sensorDataHistory.timestamps.length === 0) {
          alert('No session data to export');
          return;
        }
        
        const sessionData = therapeuticGolf.sessionData;
        
        // Create detailed CSV with all sensor data
        let csvContent = 'Timestamp,Flex1,Flex2,Flex3,IMU_Tilt,Movement_Speed,Action_Type,Auto_Collection_Fixed,Golf_State\n';
        
        for (let i = 0; i < sensorDataHistory.timestamps.length; i++) {
          const actionEvent = sensorDataHistory.actionEvents.find(
            event => Math.abs(event.timestamp - sensorDataHistory.timestamps[i]) < 0.1
          );
          const actionType = actionEvent ? actionEvent.type : '';
          const movementSpeed = movementSystem.isActive ? movementSystem.currentSpeed.toFixed(3) : '0';
          
          csvContent += `${sensorDataHistory.timestamps[i].toFixed(2)},` +
                       `${sensorDataHistory.flex1[i]},` +
                       `${sensorDataHistory.flex2[i]},` +
                       `${sensorDataHistory.flex3[i]},` +
                       `${sensorDataHistory.imuTilt[i]},` +
                       `${movementSpeed},` +
                       `${actionType},` +
                       `FINAL_FIXED,` +
                       `${golfState}\n`;
        }
        
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `VR_Golf_FINAL_FIXED_SensorData_${sessionData.patientId}_${new Date().toISOString().split('T')[0]}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // =====================================
      // COIN AND FLOWER SPAWNING
      // =====================================
      
      function spawnNewCoin() {
        const coinsContainer = document.getElementById('assessment-coins');
        if (!coinsContainer) return;
        
        const spawnAreas = [
          { centerX: 0, centerZ: 15, radius: 8 },
          { centerX: -5, centerZ: 5, radius: 6 },
          { centerX: 5, centerZ: 5, radius: 6 },
          { centerX: 15, centerZ: 10, radius: 10 },
          { centerX: 25, centerZ: 5, radius: 8 },
          { centerX: -15, centerZ: 10, radius: 10 },
          { centerX: -25, centerZ: 5, radius: 8 },
          { centerX: 0, centerZ: 25, radius: 12 },
          { centerX: 10, centerZ: 20, radius: 8 },
          { centerX: -10, centerZ: 20, radius: 8 }
        ];
        
        const area = spawnAreas[Math.floor(Math.random() * spawnAreas.length)];
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * area.radius;
        
        let x = area.centerX + Math.cos(angle) * distance;
        let z = area.centerZ + Math.sin(angle) * distance;
        
        // Avoid golf course areas
        if (z < -10 && z > -40) {
          if (Math.abs(x - 20) < 20 || Math.abs(x + 20) < 20) {
            z = z < -25 ? -45 : -5;
          }
        }
        
        const coinContainer = document.createElement('a-entity');
        coinContainer.setAttribute('class', 'assessment-coin gazeable');
        coinContainer.setAttribute('position', `${x} 0.1 ${z}`);
        
        const gltfModel = document.createElement('a-entity');
        gltfModel.setAttribute('gltf-model', 'https://jst0605-coder.github.io/jst/Coin.glb');
        gltfModel.setAttribute('scale', '0.7 0.7 0.7');
        gltfModel.setAttribute('shadow', 'cast: true');
        gltfModel.setAttribute('animation', {
          property: 'rotation',
          to: '0 360 0',
          dur: 2000,
          loop: true
        });
        
        gltfModel.setAttribute('animation__pulse', {
          property: 'scale',
          to: '0.8 0.8 0.8',
          dur: 1500,
          loop: true,
          dir: 'alternate'
        });
        
        coinContainer.appendChild(gltfModel);
        coinsContainer.appendChild(coinContainer);
        
        coinContainer.setAttribute('scale', '0 0 0');
        coinContainer.setAttribute('animation__spawn', {
          property: 'scale',
          to: '1 1 1',
          dur: 600
        });
      }

      function spawnAssessmentCoins() {
        const coinsToSpawn = 8 + Math.floor(Math.random() * 5);
        
        for (let i = 0; i < coinsToSpawn; i++) {
          setTimeout(() => {
            spawnNewCoin();
          }, i * 1500);
        }
      }

      // Initialize scattered flowers
      function initializeScatteredFlowers() {
        const flowerModels = [
          "https://jst0605-coder.github.io/jst/daisy_pink_flower_bush.glb",
          "https://jst0605-coder.github.io/jst/orange_pincushion_flower.glb",
          "https://jst0605-coder.github.io/jst/spring_lungwort_flowering_plants.glb"
        ];
        
        const numFlowers = 20;
        const flowersParent = document.getElementById("scattered-flowers");
        
        if (!flowersParent) return;
        
        const avoidZones = [
          { x: -20, z: -25, radius: 18 },
          { x: 20, z: -25, radius: 20 },
          { x: 0, z: 8, radius: 8 },
          { x: 0, z: 18, radius: 12 }
        ];
        
        const placedFlowers = [];
        let attempts = 0;
        const maxAttempts = 150;
        
        while (placedFlowers.length < numFlowers && attempts < maxAttempts) {
          attempts++;
          
          const x = (Math.random() - 0.5) * 100;
          const z = (Math.random() - 0.5) * 80;
          
          let tooClose = false;
          
          for (const zone of avoidZones) {
            const distance = Math.sqrt(Math.pow(x - zone.x, 2) + Math.pow(z - zone.z, 2));
            if (distance < zone.radius) {
              tooClose = true;
              break;
            }
          }
          
          if (!tooClose) {
            for (const existing of placedFlowers) {
              const distance = Math.sqrt(Math.pow(x - existing.x, 2) + Math.pow(z - existing.z, 2));
              if (distance < 6) {
                tooClose = true;
                break;
              }
            }
          }
          
          if (Math.abs(x) > 45 || Math.abs(z) > 35) {
            tooClose = true;
          }
          
          if (!tooClose) {
            const flower = document.createElement("a-entity");
            flower.setAttribute("gltf-model", flowerModels[placedFlowers.length % flowerModels.length]);
            flower.setAttribute("class", "discoverable-flower gazeable");
            
            const y = 0.1;
            flower.setAttribute("position", `${x.toFixed(2)} ${y} ${z.toFixed(2)}`);
            
            const scale = (Math.random() * 1.5 + 1.0).toFixed(2);
            flower.setAttribute("scale", `${scale} ${scale} ${scale}`);
            
            const rotation = Math.random() * 360;
            flower.setAttribute("rotation", `0 ${rotation.toFixed(2)} 0`);
            
            const swayDuration = 6000 + Math.random() * 4000;
            const swayAmount = 5 + Math.random() * 8;
            flower.setAttribute("animation__sway", {
              property: "rotation",
              to: `0 ${(rotation + swayAmount).toFixed(2)} 0`,
              dur: swayDuration,
              loop: true,
              dir: "alternate"
            });
            
            flower.setAttribute("shadow", "cast: true");
            
            flowersParent.appendChild(flower);
            placedFlowers.push({ x, z });
          }
        }
        
        console.log(`üå∏ ${placedFlowers.length} flowers spawned (final fixed version)`);
      }

      // Animal AI Component
      AFRAME.registerComponent('animal-ai', {
        schema: {
          speed: { type: 'number', default: 1.0 },
          wanderRadius: { type: 'number', default: 15 },
          homePosition: { type: 'string', default: '0 0 0' }
        },
        
        init: function () {
          const homePos = this.data.homePosition.split(' ');
          this.homePosition = {
            x: parseFloat(homePos[0]),
            y: parseFloat(homePos[1]),
            z: parseFloat(homePos[2])
          };
          
          this.currentTarget = null;
          this.isMoving = false;
          this.pauseTime = 0;
          this.movementSpeed = this.data.speed;
          this.updateInterval = 150;
          this.lastUpdate = 0;
          this.greenZoneRadius = 65;
          
          this.setNewWanderTarget();
        },
        
        setNewWanderTarget: function() {
          let attempts = 0;
          let validTarget = false;
          
          while (!validTarget && attempts < 8) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * this.data.wanderRadius;
            
            this.currentTarget = {
              x: this.homePosition.x + Math.cos(angle) * distance,
              y: this.homePosition.y,
              z: this.homePosition.z + Math.sin(angle) * distance
            };
            
            const distanceFromCenter = Math.sqrt(
              this.currentTarget.x * this.currentTarget.x + 
              this.currentTarget.z * this.currentTarget.z
            );
            
            if (distanceFromCenter <= this.greenZoneRadius - 5) {
              let inGolfArea = false;
              if (this.currentTarget.z < -10 && this.currentTarget.z > -40) {
                if (Math.abs(this.currentTarget.x - 20) < 18 || Math.abs(this.currentTarget.x + 20) < 18) {
                  inGolfArea = true;
                }
              }
              
              if (!inGolfArea) {
                validTarget = true;
              }
            }
            
            attempts++;
          }
          
          if (!validTarget) {
            const centerAngle = Math.random() * Math.PI * 2;
            const centerDistance = Math.random() * 20;
            this.currentTarget = {
              x: Math.cos(centerAngle) * centerDistance,
              y: this.homePosition.y,
              z: Math.sin(centerAngle) * centerDistance
            };
          }
          
          this.isMoving = true;
          this.pauseTime = 0;
        },
        
        tick: function(time, timeDelta) {
          if (time - this.lastUpdate < this.updateInterval) {
            return;
          }
          this.lastUpdate = time;
          
          if (this.pauseTime > 0) {
            this.pauseTime -= timeDelta;
            if (this.pauseTime <= 0) {
              this.setNewWanderTarget();
            }
            return;
          }
          
          if (this.isMoving && this.currentTarget) {
            const currentPos = this.el.getAttribute('position');
            
            const distanceFromCenter = Math.sqrt(
              currentPos.x * currentPos.x + 
              currentPos.z * currentPos.z
            );
            
            if (distanceFromCenter >= this.greenZoneRadius - 10) {
              const centerAngle = Math.atan2(-currentPos.z, -currentPos.x);
              const centerDistance = Math.random() * 15 + 10;
              this.currentTarget = {
                x: Math.cos(centerAngle) * centerDistance,
                y: this.homePosition.y,
                z: Math.sin(centerAngle) * centerDistance
              };
            }
            
            const dx = this.currentTarget.x - currentPos.x;
            const dz = this.currentTarget.z - currentPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance < 1.5) {
              this.isMoving = false;
              this.pauseTime = 3000 + Math.random() * 4000;
            } else {
              const moveDistance = (this.movementSpeed * timeDelta) / 1000;
              const normalizedDx = (dx / distance) * moveDistance;
              const normalizedDz = (dz / distance) * moveDistance;
              
              const newPosition = {
                x: currentPos.x + normalizedDx,
                y: currentPos.y,
                z: currentPos.z + normalizedDz
              };
              
              const newDistanceFromCenter = Math.sqrt(
                newPosition.x * newPosition.x + 
                newPosition.z * newPosition.z
              );
              
              if (newDistanceFromCenter <= this.greenZoneRadius - 2) {
                this.el.setAttribute('position', newPosition);
                
                const rotation = Math.atan2(dx, dz) * 180 / Math.PI;
                this.el.setAttribute('rotation', `0 ${rotation} 0`);
              } else {
                this.isMoving = false;
                this.pauseTime = 1000;
              }
            }
          }
        }
      });

      // =====================================
      // INITIALIZATION AND VR DETECTION
      // =====================================
      
      // VR Mode Detection
      function detectVRMode() {
        const scene = document.querySelector('a-scene');
        if (scene) {
          scene.addEventListener('enter-vr', () => {
            isInVRMode = true;
            document.body.classList.add('vr-mode');
            console.log('ü•Ω Entered VR mode - final fixed version active');
          });
          
          scene.addEventListener('exit-vr', () => {
            isInVRMode = false;
            document.body.classList.remove('vr-mode');
            console.log('üñ•Ô∏è Exited VR mode - final fixed version continues');
          });
        }
      }

      // Initialize everything when page loads
      document.addEventListener('DOMContentLoaded', function() {
        console.log('üöÄ VR Therapeutic Golf World FINAL FIXED VERSION loaded successfully!');
        console.log('');
        console.log('‚úÖ FINAL FIXES IMPLEMENTED:');
        console.log('  üö´ ZERO AUTO-COLLECTION: Coins require flex + close proximity');
        console.log('  üö´ ZERO AUTO-TOUCH: Animals require flex + close proximity');
        console.log('  ‚õ≥ GOLF NEVER STUCK: Forced timeouts and exits prevent hanging');
        console.log('  üîÑ BALL ALWAYS RETURNS: Guaranteed reset system with multiple attempts');
        console.log('  üéûÔ∏è ALL ANIMATIONS FIXED: No more easing errors');
        console.log('  üèÉ SMOOTH MOVEMENT: Optimized movement system');
        console.log('');
        console.log('üéÆ FINAL FIXED CONTROLS:');
        console.log('  ‚Ä¢ üö∂ WALK: Smooth movement only when elbow deliberately bent (threshold: 15¬∞)');
        console.log('  ‚Ä¢ üí∞ COLLECT: Must flex finger (60+) AND be within 2.5m proximity');
        console.log('  ‚Ä¢ üêæ TOUCH: Must flex finger (60+) AND be within 2.5m proximity');
        console.log('  ‚Ä¢ üéØ GOLF: Look at ball + hold finger flex');
        console.log('  ‚Ä¢ ‚ö° POWER: Add elbow movement while holding flex');
        console.log('  ‚Ä¢ üèåÔ∏è SWING: Release either control to swing');
        console.log('  ‚Ä¢ üîÑ TIMEOUT: Golf auto-exits after 10s to prevent getting stuck');
        console.log('  ‚Ä¢ üîÑ BALL RESET: Ball GUARANTEED to return to tee after every shot');
        console.log('');
        console.log('üîß FINAL FIXED THRESHOLDS:');
        console.log(`  ‚Ä¢ Flex Threshold: ${sensorThresholds.flexThreshold} (much higher - no auto-collection)`);
        console.log(`  ‚Ä¢ IMU Threshold: ${sensorThresholds.imuThreshold} (much higher - no auto-movement)`);
        console.log(`  ‚Ä¢ Proximity Distance: ${sensorThresholds.proximityDistance}m (much smaller - deliberate only)`);
        console.log(`  ‚Ä¢ Action Cooldown: ${actionCooldown}ms (prevents rapid triggers)`);
        console.log('');
        console.log('üõ°Ô∏è SAFEGUARDS IMPLEMENTED:');
        console.log('  ‚Ä¢ Golf timeout prevents infinite hanging in golf mode');
        console.log('  ‚Ä¢ Forced golf exit function ensures return to normal mode');
        console.log('  ‚Ä¢ Multiple ball reset attempts guarantee ball returns to tee');
        console.log('  ‚Ä¢ Higher thresholds eliminate accidental auto-collection');
        console.log('  ‚Ä¢ Strict proximity requirements for all interactions');
        console.log('');
        
        updateModeIndicator();
        detectVRMode();
        
        // Mobile VR support
        if (/Android|iPhone|iPad/.test(navigator.userAgent)) {
          if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            let permissionRequested = false;
            document.addEventListener('touchstart', function requestPermissionOnce() {
              if (!permissionRequested) {
                permissionRequested = true;
                DeviceOrientationEvent.requestPermission()
                  .then(response => {
                    console.log('üì± Device orientation permission:', response);
                  })
                  .catch(console.error);
                document.removeEventListener('touchstart', requestPermissionOnce);
              }
            });
          }
        }
      });

      // Enhanced coin spawning (optimized intervals)
      setInterval(() => {
        if (gameState === 'playing') {
          const existingCoins = document.querySelectorAll('.assessment-coin').length;
          
          if (existingCoins < 8) {
            const coinsToSpawn = Math.min(2, 12 - existingCoins);
            
            for (let i = 0; i < coinsToSpawn; i++) {
              setTimeout(() => spawnNewCoin(), i * 800);
            }
          }
        }
      }, 10000);

      // Keep WebSocket connection alive
      setInterval(() => {
        if (esp32WebSocket && esp32WebSocket.readyState === WebSocket.OPEN) {
          try {
            esp32WebSocket.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));
          } catch (error) {
            console.log('WebSocket ping failed:', error);
          }
        }
      }, 30000);

      // Performance monitoring (disabled by default)
      let performanceMonitor = {
        enabled: false,
        frameCount: 0,
        lastTime: performance.now(),
        
        tick: function() {
          if (!this.enabled) return;
          
          this.frameCount++;
          const now = performance.now();
          
          if (now - this.lastTime >= 5000) {
            const fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
            console.log(`üéÆ Performance: ${fps}fps | Movement: ${movementSystem.isActive} | Speed: ${movementSystem.currentSpeed.toFixed(3)} | Golf: ${golfState}`);
            
            this.frameCount = 0;
            this.lastTime = now;
          }
          
          requestAnimationFrame(() => this.tick());
        }
      };
      
      // Start performance monitoring if enabled
      if (performanceMonitor.enabled) {
        performanceMonitor.tick();
      }

      // Additional safeguard: Force exit golf mode every 15 seconds if stuck
      setInterval(() => {
        if (golfState !== 'none') {
          const now = Date.now();
          if (now - lastActionTime > 15000) {
            console.log('üö® EMERGENCY: Golf mode stuck for 15+ seconds - forcing exit');
            forceExitGolf('emergency timeout - stuck for 15+ seconds');
          }
        }
      }, 5000);

      // Final safeguard: Ball reset check every 30 seconds
      setInterval(() => {
        if (gameState === 'playing' || gameState === 'demo') {
          const easyBall = document.getElementById('easy-ball');
          const challengingBall = document.getElementById('challenging-ball');
          
          if (easyBall) {
            const easyPos = easyBall.getAttribute('position');
            if (easyPos.y > 2 || Math.abs(easyPos.x) > 5 || Math.abs(easyPos.z - 12) > 5) {
              console.log('üö® SAFEGUARD: Easy ball out of position - forcing reset');
              forcedResetGolfBallToTee(true);
            }
          }
          
          if (challengingBall) {
            const challengingPos = challengingBall.getAttribute('position');
            if (challengingPos.y > 2 || Math.abs(challengingPos.x) > 5 || Math.abs(challengingPos.z - 15) > 5) {
              console.log('üö® SAFEGUARD: Challenging ball out of position - forcing reset');
              forcedResetGolfBallToTee(false);
            }
          }
        }
      }, 30000);

    </script>
  </body>
</html>